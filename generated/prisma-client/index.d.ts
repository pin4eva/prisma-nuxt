// Code generated by Prisma (prisma@1.34.8). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  cases: (where?: CasesWhereInput) => Promise<boolean>;
  category: (where?: CategoryWhereInput) => Promise<boolean>;
  comment: (where?: CommentWhereInput) => Promise<boolean>;
  contents: (where?: ContentsWhereInput) => Promise<boolean>;
  counsel: (where?: CounselWhereInput) => Promise<boolean>;
  faq: (where?: FaqWhereInput) => Promise<boolean>;
  issues: (where?: IssuesWhereInput) => Promise<boolean>;
  judge: (where?: JudgeWhereInput) => Promise<boolean>;
  location: (where?: LocationWhereInput) => Promise<boolean>;
  post: (where?: PostWhereInput) => Promise<boolean>;
  question: (where?: QuestionWhereInput) => Promise<boolean>;
  ratios: (where?: RatiosWhereInput) => Promise<boolean>;
  report: (where?: ReportWhereInput) => Promise<boolean>;
  sub: (where?: SubWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  vol: (where?: VolWhereInput) => Promise<boolean>;
  isActive: (where?: isActiveWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  cases: (where: CasesWhereUniqueInput) => CasesNullablePromise;
  caseses: (args?: {
    where?: CasesWhereInput;
    orderBy?: CasesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Cases>;
  casesesConnection: (args?: {
    where?: CasesWhereInput;
    orderBy?: CasesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CasesConnectionPromise;
  category: (where: CategoryWhereUniqueInput) => CategoryNullablePromise;
  categories: (args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Category>;
  categoriesConnection: (args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CategoryConnectionPromise;
  comment: (where: CommentWhereUniqueInput) => CommentNullablePromise;
  comments: (args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Comment>;
  commentsConnection: (args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CommentConnectionPromise;
  contents: (where: ContentsWhereUniqueInput) => ContentsNullablePromise;
  contentses: (args?: {
    where?: ContentsWhereInput;
    orderBy?: ContentsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Contents>;
  contentsesConnection: (args?: {
    where?: ContentsWhereInput;
    orderBy?: ContentsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ContentsConnectionPromise;
  counsel: (where: CounselWhereUniqueInput) => CounselNullablePromise;
  counsels: (args?: {
    where?: CounselWhereInput;
    orderBy?: CounselOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Counsel>;
  counselsConnection: (args?: {
    where?: CounselWhereInput;
    orderBy?: CounselOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CounselConnectionPromise;
  faq: (where: FaqWhereUniqueInput) => FaqNullablePromise;
  faqs: (args?: {
    where?: FaqWhereInput;
    orderBy?: FaqOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Faq>;
  faqsConnection: (args?: {
    where?: FaqWhereInput;
    orderBy?: FaqOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FaqConnectionPromise;
  issues: (where: IssuesWhereUniqueInput) => IssuesNullablePromise;
  issueses: (args?: {
    where?: IssuesWhereInput;
    orderBy?: IssuesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Issues>;
  issuesesConnection: (args?: {
    where?: IssuesWhereInput;
    orderBy?: IssuesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => IssuesConnectionPromise;
  judge: (where: JudgeWhereUniqueInput) => JudgeNullablePromise;
  judges: (args?: {
    where?: JudgeWhereInput;
    orderBy?: JudgeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Judge>;
  judgesConnection: (args?: {
    where?: JudgeWhereInput;
    orderBy?: JudgeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => JudgeConnectionPromise;
  location: (where: LocationWhereUniqueInput) => LocationNullablePromise;
  locations: (args?: {
    where?: LocationWhereInput;
    orderBy?: LocationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Location>;
  locationsConnection: (args?: {
    where?: LocationWhereInput;
    orderBy?: LocationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LocationConnectionPromise;
  post: (where: PostWhereUniqueInput) => PostNullablePromise;
  posts: (args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Post>;
  postsConnection: (args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PostConnectionPromise;
  question: (where: QuestionWhereUniqueInput) => QuestionNullablePromise;
  questions: (args?: {
    where?: QuestionWhereInput;
    orderBy?: QuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Question>;
  questionsConnection: (args?: {
    where?: QuestionWhereInput;
    orderBy?: QuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => QuestionConnectionPromise;
  ratios: (where: RatiosWhereUniqueInput) => RatiosNullablePromise;
  ratioses: (args?: {
    where?: RatiosWhereInput;
    orderBy?: RatiosOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Ratios>;
  ratiosesConnection: (args?: {
    where?: RatiosWhereInput;
    orderBy?: RatiosOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RatiosConnectionPromise;
  report: (where: ReportWhereUniqueInput) => ReportNullablePromise;
  reports: (args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Report>;
  reportsConnection: (args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ReportConnectionPromise;
  sub: (where: SubWhereUniqueInput) => SubNullablePromise;
  subs: (args?: {
    where?: SubWhereInput;
    orderBy?: SubOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Sub>;
  subsConnection: (args?: {
    where?: SubWhereInput;
    orderBy?: SubOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SubConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  vol: (where: VolWhereUniqueInput) => VolNullablePromise;
  vols: (args?: {
    where?: VolWhereInput;
    orderBy?: VolOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Vol>;
  volsConnection: (args?: {
    where?: VolWhereInput;
    orderBy?: VolOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => VolConnectionPromise;
  isActive: (where: isActiveWhereUniqueInput) => isActiveNullablePromise;
  isActives: (args?: {
    where?: isActiveWhereInput;
    orderBy?: isActiveOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<isActive>;
  isActivesConnection: (args?: {
    where?: isActiveWhereInput;
    orderBy?: isActiveOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => isActiveConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCases: (data: CasesCreateInput) => CasesPromise;
  updateCases: (args: {
    data: CasesUpdateInput;
    where: CasesWhereUniqueInput;
  }) => CasesPromise;
  updateManyCaseses: (args: {
    data: CasesUpdateManyMutationInput;
    where?: CasesWhereInput;
  }) => BatchPayloadPromise;
  upsertCases: (args: {
    where: CasesWhereUniqueInput;
    create: CasesCreateInput;
    update: CasesUpdateInput;
  }) => CasesPromise;
  deleteCases: (where: CasesWhereUniqueInput) => CasesPromise;
  deleteManyCaseses: (where?: CasesWhereInput) => BatchPayloadPromise;
  createCategory: (data: CategoryCreateInput) => CategoryPromise;
  updateCategory: (args: {
    data: CategoryUpdateInput;
    where: CategoryWhereUniqueInput;
  }) => CategoryPromise;
  updateManyCategories: (args: {
    data: CategoryUpdateManyMutationInput;
    where?: CategoryWhereInput;
  }) => BatchPayloadPromise;
  upsertCategory: (args: {
    where: CategoryWhereUniqueInput;
    create: CategoryCreateInput;
    update: CategoryUpdateInput;
  }) => CategoryPromise;
  deleteCategory: (where: CategoryWhereUniqueInput) => CategoryPromise;
  deleteManyCategories: (where?: CategoryWhereInput) => BatchPayloadPromise;
  createComment: (data: CommentCreateInput) => CommentPromise;
  updateComment: (args: {
    data: CommentUpdateInput;
    where: CommentWhereUniqueInput;
  }) => CommentPromise;
  updateManyComments: (args: {
    data: CommentUpdateManyMutationInput;
    where?: CommentWhereInput;
  }) => BatchPayloadPromise;
  upsertComment: (args: {
    where: CommentWhereUniqueInput;
    create: CommentCreateInput;
    update: CommentUpdateInput;
  }) => CommentPromise;
  deleteComment: (where: CommentWhereUniqueInput) => CommentPromise;
  deleteManyComments: (where?: CommentWhereInput) => BatchPayloadPromise;
  createContents: (data: ContentsCreateInput) => ContentsPromise;
  updateContents: (args: {
    data: ContentsUpdateInput;
    where: ContentsWhereUniqueInput;
  }) => ContentsPromise;
  updateManyContentses: (args: {
    data: ContentsUpdateManyMutationInput;
    where?: ContentsWhereInput;
  }) => BatchPayloadPromise;
  upsertContents: (args: {
    where: ContentsWhereUniqueInput;
    create: ContentsCreateInput;
    update: ContentsUpdateInput;
  }) => ContentsPromise;
  deleteContents: (where: ContentsWhereUniqueInput) => ContentsPromise;
  deleteManyContentses: (where?: ContentsWhereInput) => BatchPayloadPromise;
  createCounsel: (data: CounselCreateInput) => CounselPromise;
  updateCounsel: (args: {
    data: CounselUpdateInput;
    where: CounselWhereUniqueInput;
  }) => CounselPromise;
  updateManyCounsels: (args: {
    data: CounselUpdateManyMutationInput;
    where?: CounselWhereInput;
  }) => BatchPayloadPromise;
  upsertCounsel: (args: {
    where: CounselWhereUniqueInput;
    create: CounselCreateInput;
    update: CounselUpdateInput;
  }) => CounselPromise;
  deleteCounsel: (where: CounselWhereUniqueInput) => CounselPromise;
  deleteManyCounsels: (where?: CounselWhereInput) => BatchPayloadPromise;
  createFaq: (data: FaqCreateInput) => FaqPromise;
  updateFaq: (args: {
    data: FaqUpdateInput;
    where: FaqWhereUniqueInput;
  }) => FaqPromise;
  updateManyFaqs: (args: {
    data: FaqUpdateManyMutationInput;
    where?: FaqWhereInput;
  }) => BatchPayloadPromise;
  upsertFaq: (args: {
    where: FaqWhereUniqueInput;
    create: FaqCreateInput;
    update: FaqUpdateInput;
  }) => FaqPromise;
  deleteFaq: (where: FaqWhereUniqueInput) => FaqPromise;
  deleteManyFaqs: (where?: FaqWhereInput) => BatchPayloadPromise;
  createIssues: (data: IssuesCreateInput) => IssuesPromise;
  updateIssues: (args: {
    data: IssuesUpdateInput;
    where: IssuesWhereUniqueInput;
  }) => IssuesPromise;
  updateManyIssueses: (args: {
    data: IssuesUpdateManyMutationInput;
    where?: IssuesWhereInput;
  }) => BatchPayloadPromise;
  upsertIssues: (args: {
    where: IssuesWhereUniqueInput;
    create: IssuesCreateInput;
    update: IssuesUpdateInput;
  }) => IssuesPromise;
  deleteIssues: (where: IssuesWhereUniqueInput) => IssuesPromise;
  deleteManyIssueses: (where?: IssuesWhereInput) => BatchPayloadPromise;
  createJudge: (data: JudgeCreateInput) => JudgePromise;
  updateJudge: (args: {
    data: JudgeUpdateInput;
    where: JudgeWhereUniqueInput;
  }) => JudgePromise;
  updateManyJudges: (args: {
    data: JudgeUpdateManyMutationInput;
    where?: JudgeWhereInput;
  }) => BatchPayloadPromise;
  upsertJudge: (args: {
    where: JudgeWhereUniqueInput;
    create: JudgeCreateInput;
    update: JudgeUpdateInput;
  }) => JudgePromise;
  deleteJudge: (where: JudgeWhereUniqueInput) => JudgePromise;
  deleteManyJudges: (where?: JudgeWhereInput) => BatchPayloadPromise;
  createLocation: (data: LocationCreateInput) => LocationPromise;
  updateLocation: (args: {
    data: LocationUpdateInput;
    where: LocationWhereUniqueInput;
  }) => LocationPromise;
  updateManyLocations: (args: {
    data: LocationUpdateManyMutationInput;
    where?: LocationWhereInput;
  }) => BatchPayloadPromise;
  upsertLocation: (args: {
    where: LocationWhereUniqueInput;
    create: LocationCreateInput;
    update: LocationUpdateInput;
  }) => LocationPromise;
  deleteLocation: (where: LocationWhereUniqueInput) => LocationPromise;
  deleteManyLocations: (where?: LocationWhereInput) => BatchPayloadPromise;
  createPost: (data: PostCreateInput) => PostPromise;
  updatePost: (args: {
    data: PostUpdateInput;
    where: PostWhereUniqueInput;
  }) => PostPromise;
  updateManyPosts: (args: {
    data: PostUpdateManyMutationInput;
    where?: PostWhereInput;
  }) => BatchPayloadPromise;
  upsertPost: (args: {
    where: PostWhereUniqueInput;
    create: PostCreateInput;
    update: PostUpdateInput;
  }) => PostPromise;
  deletePost: (where: PostWhereUniqueInput) => PostPromise;
  deleteManyPosts: (where?: PostWhereInput) => BatchPayloadPromise;
  createQuestion: (data: QuestionCreateInput) => QuestionPromise;
  updateQuestion: (args: {
    data: QuestionUpdateInput;
    where: QuestionWhereUniqueInput;
  }) => QuestionPromise;
  updateManyQuestions: (args: {
    data: QuestionUpdateManyMutationInput;
    where?: QuestionWhereInput;
  }) => BatchPayloadPromise;
  upsertQuestion: (args: {
    where: QuestionWhereUniqueInput;
    create: QuestionCreateInput;
    update: QuestionUpdateInput;
  }) => QuestionPromise;
  deleteQuestion: (where: QuestionWhereUniqueInput) => QuestionPromise;
  deleteManyQuestions: (where?: QuestionWhereInput) => BatchPayloadPromise;
  createRatios: (data: RatiosCreateInput) => RatiosPromise;
  updateRatios: (args: {
    data: RatiosUpdateInput;
    where: RatiosWhereUniqueInput;
  }) => RatiosPromise;
  updateManyRatioses: (args: {
    data: RatiosUpdateManyMutationInput;
    where?: RatiosWhereInput;
  }) => BatchPayloadPromise;
  upsertRatios: (args: {
    where: RatiosWhereUniqueInput;
    create: RatiosCreateInput;
    update: RatiosUpdateInput;
  }) => RatiosPromise;
  deleteRatios: (where: RatiosWhereUniqueInput) => RatiosPromise;
  deleteManyRatioses: (where?: RatiosWhereInput) => BatchPayloadPromise;
  createReport: (data: ReportCreateInput) => ReportPromise;
  updateReport: (args: {
    data: ReportUpdateInput;
    where: ReportWhereUniqueInput;
  }) => ReportPromise;
  updateManyReports: (args: {
    data: ReportUpdateManyMutationInput;
    where?: ReportWhereInput;
  }) => BatchPayloadPromise;
  upsertReport: (args: {
    where: ReportWhereUniqueInput;
    create: ReportCreateInput;
    update: ReportUpdateInput;
  }) => ReportPromise;
  deleteReport: (where: ReportWhereUniqueInput) => ReportPromise;
  deleteManyReports: (where?: ReportWhereInput) => BatchPayloadPromise;
  createSub: (data: SubCreateInput) => SubPromise;
  updateSub: (args: {
    data: SubUpdateInput;
    where: SubWhereUniqueInput;
  }) => SubPromise;
  updateManySubs: (args: {
    data: SubUpdateManyMutationInput;
    where?: SubWhereInput;
  }) => BatchPayloadPromise;
  upsertSub: (args: {
    where: SubWhereUniqueInput;
    create: SubCreateInput;
    update: SubUpdateInput;
  }) => SubPromise;
  deleteSub: (where: SubWhereUniqueInput) => SubPromise;
  deleteManySubs: (where?: SubWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createVol: (data: VolCreateInput) => VolPromise;
  updateVol: (args: {
    data: VolUpdateInput;
    where: VolWhereUniqueInput;
  }) => VolPromise;
  updateManyVols: (args: {
    data: VolUpdateManyMutationInput;
    where?: VolWhereInput;
  }) => BatchPayloadPromise;
  upsertVol: (args: {
    where: VolWhereUniqueInput;
    create: VolCreateInput;
    update: VolUpdateInput;
  }) => VolPromise;
  deleteVol: (where: VolWhereUniqueInput) => VolPromise;
  deleteManyVols: (where?: VolWhereInput) => BatchPayloadPromise;
  createisActive: (data: isActiveCreateInput) => isActivePromise;
  updateisActive: (args: {
    data: isActiveUpdateInput;
    where: isActiveWhereUniqueInput;
  }) => isActivePromise;
  updateManyisActives: (args: {
    data: isActiveUpdateManyMutationInput;
    where?: isActiveWhereInput;
  }) => BatchPayloadPromise;
  upsertisActive: (args: {
    where: isActiveWhereUniqueInput;
    create: isActiveCreateInput;
    update: isActiveUpdateInput;
  }) => isActivePromise;
  deleteisActive: (where: isActiveWhereUniqueInput) => isActivePromise;
  deleteManyisActives: (where?: isActiveWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  cases: (
    where?: CasesSubscriptionWhereInput
  ) => CasesSubscriptionPayloadSubscription;
  category: (
    where?: CategorySubscriptionWhereInput
  ) => CategorySubscriptionPayloadSubscription;
  comment: (
    where?: CommentSubscriptionWhereInput
  ) => CommentSubscriptionPayloadSubscription;
  contents: (
    where?: ContentsSubscriptionWhereInput
  ) => ContentsSubscriptionPayloadSubscription;
  counsel: (
    where?: CounselSubscriptionWhereInput
  ) => CounselSubscriptionPayloadSubscription;
  faq: (
    where?: FaqSubscriptionWhereInput
  ) => FaqSubscriptionPayloadSubscription;
  issues: (
    where?: IssuesSubscriptionWhereInput
  ) => IssuesSubscriptionPayloadSubscription;
  judge: (
    where?: JudgeSubscriptionWhereInput
  ) => JudgeSubscriptionPayloadSubscription;
  location: (
    where?: LocationSubscriptionWhereInput
  ) => LocationSubscriptionPayloadSubscription;
  post: (
    where?: PostSubscriptionWhereInput
  ) => PostSubscriptionPayloadSubscription;
  question: (
    where?: QuestionSubscriptionWhereInput
  ) => QuestionSubscriptionPayloadSubscription;
  ratios: (
    where?: RatiosSubscriptionWhereInput
  ) => RatiosSubscriptionPayloadSubscription;
  report: (
    where?: ReportSubscriptionWhereInput
  ) => ReportSubscriptionPayloadSubscription;
  sub: (
    where?: SubSubscriptionWhereInput
  ) => SubSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  vol: (
    where?: VolSubscriptionWhereInput
  ) => VolSubscriptionPayloadSubscription;
  isActive: (
    where?: isActiveSubscriptionWhereInput
  ) => isActiveSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type JudgeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "title_ASC"
  | "title_DESC"
  | "image_ASC"
  | "image_DESC"
  | "bio_ASC"
  | "bio_DESC"
  | "dob_ASC"
  | "dob_DESC"
  | "State_ASC"
  | "State_DESC"
  | "ctb_ASC"
  | "ctb_DESC"
  | "education_ASC"
  | "education_DESC"
  | "likes_ASC"
  | "likes_DESC"
  | "remark_ASC"
  | "remark_DESC";

export type CasesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "likes_ASC"
  | "likes_DESC"
  | "appellant_ASC"
  | "appellant_DESC"
  | "respondent_ASC"
  | "respondent_DESC"
  | "suit_no_ASC"
  | "suit_no_DESC"
  | "page_no_ASC"
  | "page_no_DESC"
  | "State_ASC"
  | "State_DESC"
  | "cat_ASC"
  | "cat_DESC"
  | "appeal_ASC"
  | "appeal_DESC"
  | "court_ASC"
  | "court_DESC"
  | "date_ASC"
  | "date_DESC"
  | "catchwords_ASC"
  | "catchwords_DESC"
  | "summary_ASC"
  | "summary_DESC"
  | "judgement_ASC"
  | "judgement_DESC"
  | "cited_ASC"
  | "cited_DESC"
  | "books_cited_ASC"
  | "books_cited_DESC"
  | "determinations_ASC"
  | "determinations_DESC";

export type VolOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "part_no_ASC"
  | "part_no_DESC"
  | "year_ASC"
  | "year_DESC";

export type RatiosOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "heading_ASC"
  | "heading_DESC";

export type FaqOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "desc_ASC"
  | "desc_DESC";

export type QuestionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "qns_ASC"
  | "qns_DESC"
  | "ans_ASC"
  | "ans_DESC";

export type CategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "category_ASC"
  | "category_DESC"
  | "desc_ASC"
  | "desc_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type PostOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "category_ASC"
  | "category_DESC"
  | "body_ASC"
  | "body_DESC"
  | "image_ASC"
  | "image_DESC"
  | "desc_ASC"
  | "desc_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type CommentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "body_ASC"
  | "body_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type ContentsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "ref_ASC"
  | "ref_DESC"
  | "body_ASC"
  | "body_DESC";

export type CounselOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "appellant_ASC"
  | "appellant_DESC"
  | "respondent_ASC"
  | "respondent_DESC";

export type IssuesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "status_ASC"
  | "status_DESC";

export type LocationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "town_ASC"
  | "town_DESC"
  | "state_ASC"
  | "state_DESC";

export type ReportOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "year_ASC"
  | "year_DESC";

export type SubOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "plan_ASC"
  | "plan_DESC"
  | "days_ASC"
  | "days_DESC"
  | "startedIn_ASC"
  | "startedIn_DESC"
  | "expiresIn_ASC"
  | "expiresIn_DESC"
  | "isActive_ASC"
  | "isActive_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "image_ASC"
  | "image_DESC"
  | "username_ASC"
  | "username_DESC"
  | "password_ASC"
  | "password_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "email_ASC"
  | "email_DESC"
  | "about_ASC"
  | "about_DESC"
  | "company_ASC"
  | "company_DESC"
  | "tac_ASC"
  | "tac_DESC"
  | "resetPasswordToken_ASC"
  | "resetPasswordToken_DESC"
  | "resetPasswordExpires_ASC"
  | "resetPasswordExpires_DESC"
  | "isAdmin_ASC"
  | "isAdmin_DESC"
  | "emailConfirmationToken_ASC"
  | "emailConfirmationToken_DESC"
  | "joinedDate_ASC"
  | "joinedDate_DESC";

export type isActiveOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "status_ASC"
  | "status_DESC"
  | "activedOn_ASC"
  | "activedOn_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type CasesWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface JudgeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  bio?: Maybe<String>;
  bio_not?: Maybe<String>;
  bio_in?: Maybe<String[] | String>;
  bio_not_in?: Maybe<String[] | String>;
  bio_lt?: Maybe<String>;
  bio_lte?: Maybe<String>;
  bio_gt?: Maybe<String>;
  bio_gte?: Maybe<String>;
  bio_contains?: Maybe<String>;
  bio_not_contains?: Maybe<String>;
  bio_starts_with?: Maybe<String>;
  bio_not_starts_with?: Maybe<String>;
  bio_ends_with?: Maybe<String>;
  bio_not_ends_with?: Maybe<String>;
  dob?: Maybe<DateTimeInput>;
  dob_not?: Maybe<DateTimeInput>;
  dob_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dob_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dob_lt?: Maybe<DateTimeInput>;
  dob_lte?: Maybe<DateTimeInput>;
  dob_gt?: Maybe<DateTimeInput>;
  dob_gte?: Maybe<DateTimeInput>;
  State?: Maybe<String>;
  State_not?: Maybe<String>;
  State_in?: Maybe<String[] | String>;
  State_not_in?: Maybe<String[] | String>;
  State_lt?: Maybe<String>;
  State_lte?: Maybe<String>;
  State_gt?: Maybe<String>;
  State_gte?: Maybe<String>;
  State_contains?: Maybe<String>;
  State_not_contains?: Maybe<String>;
  State_starts_with?: Maybe<String>;
  State_not_starts_with?: Maybe<String>;
  State_ends_with?: Maybe<String>;
  State_not_ends_with?: Maybe<String>;
  ctb?: Maybe<String>;
  ctb_not?: Maybe<String>;
  ctb_in?: Maybe<String[] | String>;
  ctb_not_in?: Maybe<String[] | String>;
  ctb_lt?: Maybe<String>;
  ctb_lte?: Maybe<String>;
  ctb_gt?: Maybe<String>;
  ctb_gte?: Maybe<String>;
  ctb_contains?: Maybe<String>;
  ctb_not_contains?: Maybe<String>;
  ctb_starts_with?: Maybe<String>;
  ctb_not_starts_with?: Maybe<String>;
  ctb_ends_with?: Maybe<String>;
  ctb_not_ends_with?: Maybe<String>;
  education?: Maybe<String>;
  education_not?: Maybe<String>;
  education_in?: Maybe<String[] | String>;
  education_not_in?: Maybe<String[] | String>;
  education_lt?: Maybe<String>;
  education_lte?: Maybe<String>;
  education_gt?: Maybe<String>;
  education_gte?: Maybe<String>;
  education_contains?: Maybe<String>;
  education_not_contains?: Maybe<String>;
  education_starts_with?: Maybe<String>;
  education_not_starts_with?: Maybe<String>;
  education_ends_with?: Maybe<String>;
  education_not_ends_with?: Maybe<String>;
  likes?: Maybe<Int>;
  likes_not?: Maybe<Int>;
  likes_in?: Maybe<Int[] | Int>;
  likes_not_in?: Maybe<Int[] | Int>;
  likes_lt?: Maybe<Int>;
  likes_lte?: Maybe<Int>;
  likes_gt?: Maybe<Int>;
  likes_gte?: Maybe<Int>;
  remark?: Maybe<String>;
  remark_not?: Maybe<String>;
  remark_in?: Maybe<String[] | String>;
  remark_not_in?: Maybe<String[] | String>;
  remark_lt?: Maybe<String>;
  remark_lte?: Maybe<String>;
  remark_gt?: Maybe<String>;
  remark_gte?: Maybe<String>;
  remark_contains?: Maybe<String>;
  remark_not_contains?: Maybe<String>;
  remark_starts_with?: Maybe<String>;
  remark_not_starts_with?: Maybe<String>;
  remark_ends_with?: Maybe<String>;
  remark_not_ends_with?: Maybe<String>;
  cases_every?: Maybe<CasesWhereInput>;
  cases_some?: Maybe<CasesWhereInput>;
  cases_none?: Maybe<CasesWhereInput>;
  AND?: Maybe<JudgeWhereInput[] | JudgeWhereInput>;
  OR?: Maybe<JudgeWhereInput[] | JudgeWhereInput>;
  NOT?: Maybe<JudgeWhereInput[] | JudgeWhereInput>;
}

export interface CasesWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  likes?: Maybe<Int>;
  likes_not?: Maybe<Int>;
  likes_in?: Maybe<Int[] | Int>;
  likes_not_in?: Maybe<Int[] | Int>;
  likes_lt?: Maybe<Int>;
  likes_lte?: Maybe<Int>;
  likes_gt?: Maybe<Int>;
  likes_gte?: Maybe<Int>;
  appellant?: Maybe<String>;
  appellant_not?: Maybe<String>;
  appellant_in?: Maybe<String[] | String>;
  appellant_not_in?: Maybe<String[] | String>;
  appellant_lt?: Maybe<String>;
  appellant_lte?: Maybe<String>;
  appellant_gt?: Maybe<String>;
  appellant_gte?: Maybe<String>;
  appellant_contains?: Maybe<String>;
  appellant_not_contains?: Maybe<String>;
  appellant_starts_with?: Maybe<String>;
  appellant_not_starts_with?: Maybe<String>;
  appellant_ends_with?: Maybe<String>;
  appellant_not_ends_with?: Maybe<String>;
  respondent?: Maybe<String>;
  respondent_not?: Maybe<String>;
  respondent_in?: Maybe<String[] | String>;
  respondent_not_in?: Maybe<String[] | String>;
  respondent_lt?: Maybe<String>;
  respondent_lte?: Maybe<String>;
  respondent_gt?: Maybe<String>;
  respondent_gte?: Maybe<String>;
  respondent_contains?: Maybe<String>;
  respondent_not_contains?: Maybe<String>;
  respondent_starts_with?: Maybe<String>;
  respondent_not_starts_with?: Maybe<String>;
  respondent_ends_with?: Maybe<String>;
  respondent_not_ends_with?: Maybe<String>;
  suit_no?: Maybe<String>;
  suit_no_not?: Maybe<String>;
  suit_no_in?: Maybe<String[] | String>;
  suit_no_not_in?: Maybe<String[] | String>;
  suit_no_lt?: Maybe<String>;
  suit_no_lte?: Maybe<String>;
  suit_no_gt?: Maybe<String>;
  suit_no_gte?: Maybe<String>;
  suit_no_contains?: Maybe<String>;
  suit_no_not_contains?: Maybe<String>;
  suit_no_starts_with?: Maybe<String>;
  suit_no_not_starts_with?: Maybe<String>;
  suit_no_ends_with?: Maybe<String>;
  suit_no_not_ends_with?: Maybe<String>;
  page_no?: Maybe<String>;
  page_no_not?: Maybe<String>;
  page_no_in?: Maybe<String[] | String>;
  page_no_not_in?: Maybe<String[] | String>;
  page_no_lt?: Maybe<String>;
  page_no_lte?: Maybe<String>;
  page_no_gt?: Maybe<String>;
  page_no_gte?: Maybe<String>;
  page_no_contains?: Maybe<String>;
  page_no_not_contains?: Maybe<String>;
  page_no_starts_with?: Maybe<String>;
  page_no_not_starts_with?: Maybe<String>;
  page_no_ends_with?: Maybe<String>;
  page_no_not_ends_with?: Maybe<String>;
  State?: Maybe<String>;
  State_not?: Maybe<String>;
  State_in?: Maybe<String[] | String>;
  State_not_in?: Maybe<String[] | String>;
  State_lt?: Maybe<String>;
  State_lte?: Maybe<String>;
  State_gt?: Maybe<String>;
  State_gte?: Maybe<String>;
  State_contains?: Maybe<String>;
  State_not_contains?: Maybe<String>;
  State_starts_with?: Maybe<String>;
  State_not_starts_with?: Maybe<String>;
  State_ends_with?: Maybe<String>;
  State_not_ends_with?: Maybe<String>;
  cat?: Maybe<String>;
  cat_not?: Maybe<String>;
  cat_in?: Maybe<String[] | String>;
  cat_not_in?: Maybe<String[] | String>;
  cat_lt?: Maybe<String>;
  cat_lte?: Maybe<String>;
  cat_gt?: Maybe<String>;
  cat_gte?: Maybe<String>;
  cat_contains?: Maybe<String>;
  cat_not_contains?: Maybe<String>;
  cat_starts_with?: Maybe<String>;
  cat_not_starts_with?: Maybe<String>;
  cat_ends_with?: Maybe<String>;
  cat_not_ends_with?: Maybe<String>;
  judges_every?: Maybe<JudgeWhereInput>;
  judges_some?: Maybe<JudgeWhereInput>;
  judges_none?: Maybe<JudgeWhereInput>;
  counsel?: Maybe<CounselWhereInput>;
  vol?: Maybe<VolWhereInput>;
  appeal?: Maybe<String>;
  appeal_not?: Maybe<String>;
  appeal_in?: Maybe<String[] | String>;
  appeal_not_in?: Maybe<String[] | String>;
  appeal_lt?: Maybe<String>;
  appeal_lte?: Maybe<String>;
  appeal_gt?: Maybe<String>;
  appeal_gte?: Maybe<String>;
  appeal_contains?: Maybe<String>;
  appeal_not_contains?: Maybe<String>;
  appeal_starts_with?: Maybe<String>;
  appeal_not_starts_with?: Maybe<String>;
  appeal_ends_with?: Maybe<String>;
  appeal_not_ends_with?: Maybe<String>;
  court?: Maybe<String>;
  court_not?: Maybe<String>;
  court_in?: Maybe<String[] | String>;
  court_not_in?: Maybe<String[] | String>;
  court_lt?: Maybe<String>;
  court_lte?: Maybe<String>;
  court_gt?: Maybe<String>;
  court_gte?: Maybe<String>;
  court_contains?: Maybe<String>;
  court_not_contains?: Maybe<String>;
  court_starts_with?: Maybe<String>;
  court_not_starts_with?: Maybe<String>;
  court_ends_with?: Maybe<String>;
  court_not_ends_with?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  catchwords?: Maybe<String>;
  catchwords_not?: Maybe<String>;
  catchwords_in?: Maybe<String[] | String>;
  catchwords_not_in?: Maybe<String[] | String>;
  catchwords_lt?: Maybe<String>;
  catchwords_lte?: Maybe<String>;
  catchwords_gt?: Maybe<String>;
  catchwords_gte?: Maybe<String>;
  catchwords_contains?: Maybe<String>;
  catchwords_not_contains?: Maybe<String>;
  catchwords_starts_with?: Maybe<String>;
  catchwords_not_starts_with?: Maybe<String>;
  catchwords_ends_with?: Maybe<String>;
  catchwords_not_ends_with?: Maybe<String>;
  issues?: Maybe<IssuesWhereInput>;
  summary?: Maybe<String>;
  summary_not?: Maybe<String>;
  summary_in?: Maybe<String[] | String>;
  summary_not_in?: Maybe<String[] | String>;
  summary_lt?: Maybe<String>;
  summary_lte?: Maybe<String>;
  summary_gt?: Maybe<String>;
  summary_gte?: Maybe<String>;
  summary_contains?: Maybe<String>;
  summary_not_contains?: Maybe<String>;
  summary_starts_with?: Maybe<String>;
  summary_not_starts_with?: Maybe<String>;
  summary_ends_with?: Maybe<String>;
  summary_not_ends_with?: Maybe<String>;
  judgement?: Maybe<String>;
  judgement_not?: Maybe<String>;
  judgement_in?: Maybe<String[] | String>;
  judgement_not_in?: Maybe<String[] | String>;
  judgement_lt?: Maybe<String>;
  judgement_lte?: Maybe<String>;
  judgement_gt?: Maybe<String>;
  judgement_gte?: Maybe<String>;
  judgement_contains?: Maybe<String>;
  judgement_not_contains?: Maybe<String>;
  judgement_starts_with?: Maybe<String>;
  judgement_not_starts_with?: Maybe<String>;
  judgement_ends_with?: Maybe<String>;
  judgement_not_ends_with?: Maybe<String>;
  cited?: Maybe<String>;
  cited_not?: Maybe<String>;
  cited_in?: Maybe<String[] | String>;
  cited_not_in?: Maybe<String[] | String>;
  cited_lt?: Maybe<String>;
  cited_lte?: Maybe<String>;
  cited_gt?: Maybe<String>;
  cited_gte?: Maybe<String>;
  cited_contains?: Maybe<String>;
  cited_not_contains?: Maybe<String>;
  cited_starts_with?: Maybe<String>;
  cited_not_starts_with?: Maybe<String>;
  cited_ends_with?: Maybe<String>;
  cited_not_ends_with?: Maybe<String>;
  books_cited?: Maybe<String>;
  books_cited_not?: Maybe<String>;
  books_cited_in?: Maybe<String[] | String>;
  books_cited_not_in?: Maybe<String[] | String>;
  books_cited_lt?: Maybe<String>;
  books_cited_lte?: Maybe<String>;
  books_cited_gt?: Maybe<String>;
  books_cited_gte?: Maybe<String>;
  books_cited_contains?: Maybe<String>;
  books_cited_not_contains?: Maybe<String>;
  books_cited_starts_with?: Maybe<String>;
  books_cited_not_starts_with?: Maybe<String>;
  books_cited_ends_with?: Maybe<String>;
  books_cited_not_ends_with?: Maybe<String>;
  determinations?: Maybe<String>;
  determinations_not?: Maybe<String>;
  determinations_in?: Maybe<String[] | String>;
  determinations_not_in?: Maybe<String[] | String>;
  determinations_lt?: Maybe<String>;
  determinations_lte?: Maybe<String>;
  determinations_gt?: Maybe<String>;
  determinations_gte?: Maybe<String>;
  determinations_contains?: Maybe<String>;
  determinations_not_contains?: Maybe<String>;
  determinations_starts_with?: Maybe<String>;
  determinations_not_starts_with?: Maybe<String>;
  determinations_ends_with?: Maybe<String>;
  determinations_not_ends_with?: Maybe<String>;
  AND?: Maybe<CasesWhereInput[] | CasesWhereInput>;
  OR?: Maybe<CasesWhereInput[] | CasesWhereInput>;
  NOT?: Maybe<CasesWhereInput[] | CasesWhereInput>;
}

export interface CounselWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  appellant?: Maybe<String>;
  appellant_not?: Maybe<String>;
  appellant_in?: Maybe<String[] | String>;
  appellant_not_in?: Maybe<String[] | String>;
  appellant_lt?: Maybe<String>;
  appellant_lte?: Maybe<String>;
  appellant_gt?: Maybe<String>;
  appellant_gte?: Maybe<String>;
  appellant_contains?: Maybe<String>;
  appellant_not_contains?: Maybe<String>;
  appellant_starts_with?: Maybe<String>;
  appellant_not_starts_with?: Maybe<String>;
  appellant_ends_with?: Maybe<String>;
  appellant_not_ends_with?: Maybe<String>;
  respondent?: Maybe<String>;
  respondent_not?: Maybe<String>;
  respondent_in?: Maybe<String[] | String>;
  respondent_not_in?: Maybe<String[] | String>;
  respondent_lt?: Maybe<String>;
  respondent_lte?: Maybe<String>;
  respondent_gt?: Maybe<String>;
  respondent_gte?: Maybe<String>;
  respondent_contains?: Maybe<String>;
  respondent_not_contains?: Maybe<String>;
  respondent_starts_with?: Maybe<String>;
  respondent_not_starts_with?: Maybe<String>;
  respondent_ends_with?: Maybe<String>;
  respondent_not_ends_with?: Maybe<String>;
  AND?: Maybe<CounselWhereInput[] | CounselWhereInput>;
  OR?: Maybe<CounselWhereInput[] | CounselWhereInput>;
  NOT?: Maybe<CounselWhereInput[] | CounselWhereInput>;
}

export interface VolWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  part_no?: Maybe<Int>;
  part_no_not?: Maybe<Int>;
  part_no_in?: Maybe<Int[] | Int>;
  part_no_not_in?: Maybe<Int[] | Int>;
  part_no_lt?: Maybe<Int>;
  part_no_lte?: Maybe<Int>;
  part_no_gt?: Maybe<Int>;
  part_no_gte?: Maybe<Int>;
  cases_every?: Maybe<CasesWhereInput>;
  cases_some?: Maybe<CasesWhereInput>;
  cases_none?: Maybe<CasesWhereInput>;
  year?: Maybe<Int>;
  year_not?: Maybe<Int>;
  year_in?: Maybe<Int[] | Int>;
  year_not_in?: Maybe<Int[] | Int>;
  year_lt?: Maybe<Int>;
  year_lte?: Maybe<Int>;
  year_gt?: Maybe<Int>;
  year_gte?: Maybe<Int>;
  report?: Maybe<ReportWhereInput>;
  AND?: Maybe<VolWhereInput[] | VolWhereInput>;
  OR?: Maybe<VolWhereInput[] | VolWhereInput>;
  NOT?: Maybe<VolWhereInput[] | VolWhereInput>;
}

export interface ReportWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  vols_every?: Maybe<VolWhereInput>;
  vols_some?: Maybe<VolWhereInput>;
  vols_none?: Maybe<VolWhereInput>;
  year?: Maybe<Int>;
  year_not?: Maybe<Int>;
  year_in?: Maybe<Int[] | Int>;
  year_not_in?: Maybe<Int[] | Int>;
  year_lt?: Maybe<Int>;
  year_lte?: Maybe<Int>;
  year_gt?: Maybe<Int>;
  year_gte?: Maybe<Int>;
  AND?: Maybe<ReportWhereInput[] | ReportWhereInput>;
  OR?: Maybe<ReportWhereInput[] | ReportWhereInput>;
  NOT?: Maybe<ReportWhereInput[] | ReportWhereInput>;
}

export interface IssuesWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  status?: Maybe<String>;
  status_not?: Maybe<String>;
  status_in?: Maybe<String[] | String>;
  status_not_in?: Maybe<String[] | String>;
  status_lt?: Maybe<String>;
  status_lte?: Maybe<String>;
  status_gt?: Maybe<String>;
  status_gte?: Maybe<String>;
  status_contains?: Maybe<String>;
  status_not_contains?: Maybe<String>;
  status_starts_with?: Maybe<String>;
  status_not_starts_with?: Maybe<String>;
  status_ends_with?: Maybe<String>;
  status_not_ends_with?: Maybe<String>;
  ratios_every?: Maybe<RatiosWhereInput>;
  ratios_some?: Maybe<RatiosWhereInput>;
  ratios_none?: Maybe<RatiosWhereInput>;
  AND?: Maybe<IssuesWhereInput[] | IssuesWhereInput>;
  OR?: Maybe<IssuesWhereInput[] | IssuesWhereInput>;
  NOT?: Maybe<IssuesWhereInput[] | IssuesWhereInput>;
}

export interface RatiosWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  heading?: Maybe<String>;
  heading_not?: Maybe<String>;
  heading_in?: Maybe<String[] | String>;
  heading_not_in?: Maybe<String[] | String>;
  heading_lt?: Maybe<String>;
  heading_lte?: Maybe<String>;
  heading_gt?: Maybe<String>;
  heading_gte?: Maybe<String>;
  heading_contains?: Maybe<String>;
  heading_not_contains?: Maybe<String>;
  heading_starts_with?: Maybe<String>;
  heading_not_starts_with?: Maybe<String>;
  heading_ends_with?: Maybe<String>;
  heading_not_ends_with?: Maybe<String>;
  contents?: Maybe<ContentsWhereInput>;
  AND?: Maybe<RatiosWhereInput[] | RatiosWhereInput>;
  OR?: Maybe<RatiosWhereInput[] | RatiosWhereInput>;
  NOT?: Maybe<RatiosWhereInput[] | RatiosWhereInput>;
}

export interface ContentsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  quoted?: Maybe<JudgeWhereInput>;
  ref?: Maybe<String>;
  ref_not?: Maybe<String>;
  ref_in?: Maybe<String[] | String>;
  ref_not_in?: Maybe<String[] | String>;
  ref_lt?: Maybe<String>;
  ref_lte?: Maybe<String>;
  ref_gt?: Maybe<String>;
  ref_gte?: Maybe<String>;
  ref_contains?: Maybe<String>;
  ref_not_contains?: Maybe<String>;
  ref_starts_with?: Maybe<String>;
  ref_not_starts_with?: Maybe<String>;
  ref_ends_with?: Maybe<String>;
  ref_not_ends_with?: Maybe<String>;
  body?: Maybe<String>;
  body_not?: Maybe<String>;
  body_in?: Maybe<String[] | String>;
  body_not_in?: Maybe<String[] | String>;
  body_lt?: Maybe<String>;
  body_lte?: Maybe<String>;
  body_gt?: Maybe<String>;
  body_gte?: Maybe<String>;
  body_contains?: Maybe<String>;
  body_not_contains?: Maybe<String>;
  body_starts_with?: Maybe<String>;
  body_not_starts_with?: Maybe<String>;
  body_ends_with?: Maybe<String>;
  body_not_ends_with?: Maybe<String>;
  AND?: Maybe<ContentsWhereInput[] | ContentsWhereInput>;
  OR?: Maybe<ContentsWhereInput[] | ContentsWhereInput>;
  NOT?: Maybe<ContentsWhereInput[] | ContentsWhereInput>;
}

export type CategoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface FaqWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  category?: Maybe<CategoryWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  desc?: Maybe<String>;
  desc_not?: Maybe<String>;
  desc_in?: Maybe<String[] | String>;
  desc_not_in?: Maybe<String[] | String>;
  desc_lt?: Maybe<String>;
  desc_lte?: Maybe<String>;
  desc_gt?: Maybe<String>;
  desc_gte?: Maybe<String>;
  desc_contains?: Maybe<String>;
  desc_not_contains?: Maybe<String>;
  desc_starts_with?: Maybe<String>;
  desc_not_starts_with?: Maybe<String>;
  desc_ends_with?: Maybe<String>;
  desc_not_ends_with?: Maybe<String>;
  questions_every?: Maybe<QuestionWhereInput>;
  questions_some?: Maybe<QuestionWhereInput>;
  questions_none?: Maybe<QuestionWhereInput>;
  AND?: Maybe<FaqWhereInput[] | FaqWhereInput>;
  OR?: Maybe<FaqWhereInput[] | FaqWhereInput>;
  NOT?: Maybe<FaqWhereInput[] | FaqWhereInput>;
}

export interface CategoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  category?: Maybe<String>;
  category_not?: Maybe<String>;
  category_in?: Maybe<String[] | String>;
  category_not_in?: Maybe<String[] | String>;
  category_lt?: Maybe<String>;
  category_lte?: Maybe<String>;
  category_gt?: Maybe<String>;
  category_gte?: Maybe<String>;
  category_contains?: Maybe<String>;
  category_not_contains?: Maybe<String>;
  category_starts_with?: Maybe<String>;
  category_not_starts_with?: Maybe<String>;
  category_ends_with?: Maybe<String>;
  category_not_ends_with?: Maybe<String>;
  desc?: Maybe<String>;
  desc_not?: Maybe<String>;
  desc_in?: Maybe<String[] | String>;
  desc_not_in?: Maybe<String[] | String>;
  desc_lt?: Maybe<String>;
  desc_lte?: Maybe<String>;
  desc_gt?: Maybe<String>;
  desc_gte?: Maybe<String>;
  desc_contains?: Maybe<String>;
  desc_not_contains?: Maybe<String>;
  desc_starts_with?: Maybe<String>;
  desc_not_starts_with?: Maybe<String>;
  desc_ends_with?: Maybe<String>;
  desc_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  faq_every?: Maybe<FaqWhereInput>;
  faq_some?: Maybe<FaqWhereInput>;
  faq_none?: Maybe<FaqWhereInput>;
  AND?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
  OR?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
  NOT?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
}

export interface QuestionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  qns?: Maybe<String>;
  qns_not?: Maybe<String>;
  qns_in?: Maybe<String[] | String>;
  qns_not_in?: Maybe<String[] | String>;
  qns_lt?: Maybe<String>;
  qns_lte?: Maybe<String>;
  qns_gt?: Maybe<String>;
  qns_gte?: Maybe<String>;
  qns_contains?: Maybe<String>;
  qns_not_contains?: Maybe<String>;
  qns_starts_with?: Maybe<String>;
  qns_not_starts_with?: Maybe<String>;
  qns_ends_with?: Maybe<String>;
  qns_not_ends_with?: Maybe<String>;
  ans?: Maybe<String>;
  ans_not?: Maybe<String>;
  ans_in?: Maybe<String[] | String>;
  ans_not_in?: Maybe<String[] | String>;
  ans_lt?: Maybe<String>;
  ans_lte?: Maybe<String>;
  ans_gt?: Maybe<String>;
  ans_gte?: Maybe<String>;
  ans_contains?: Maybe<String>;
  ans_not_contains?: Maybe<String>;
  ans_starts_with?: Maybe<String>;
  ans_not_starts_with?: Maybe<String>;
  ans_ends_with?: Maybe<String>;
  ans_not_ends_with?: Maybe<String>;
  AND?: Maybe<QuestionWhereInput[] | QuestionWhereInput>;
  OR?: Maybe<QuestionWhereInput[] | QuestionWhereInput>;
  NOT?: Maybe<QuestionWhereInput[] | QuestionWhereInput>;
}

export type CommentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PostWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  category?: Maybe<String>;
  category_not?: Maybe<String>;
  category_in?: Maybe<String[] | String>;
  category_not_in?: Maybe<String[] | String>;
  category_lt?: Maybe<String>;
  category_lte?: Maybe<String>;
  category_gt?: Maybe<String>;
  category_gte?: Maybe<String>;
  category_contains?: Maybe<String>;
  category_not_contains?: Maybe<String>;
  category_starts_with?: Maybe<String>;
  category_not_starts_with?: Maybe<String>;
  category_ends_with?: Maybe<String>;
  category_not_ends_with?: Maybe<String>;
  body?: Maybe<String>;
  body_not?: Maybe<String>;
  body_in?: Maybe<String[] | String>;
  body_not_in?: Maybe<String[] | String>;
  body_lt?: Maybe<String>;
  body_lte?: Maybe<String>;
  body_gt?: Maybe<String>;
  body_gte?: Maybe<String>;
  body_contains?: Maybe<String>;
  body_not_contains?: Maybe<String>;
  body_starts_with?: Maybe<String>;
  body_not_starts_with?: Maybe<String>;
  body_ends_with?: Maybe<String>;
  body_not_ends_with?: Maybe<String>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  desc?: Maybe<String>;
  desc_not?: Maybe<String>;
  desc_in?: Maybe<String[] | String>;
  desc_not_in?: Maybe<String[] | String>;
  desc_lt?: Maybe<String>;
  desc_lte?: Maybe<String>;
  desc_gt?: Maybe<String>;
  desc_gte?: Maybe<String>;
  desc_contains?: Maybe<String>;
  desc_not_contains?: Maybe<String>;
  desc_starts_with?: Maybe<String>;
  desc_not_starts_with?: Maybe<String>;
  desc_ends_with?: Maybe<String>;
  desc_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  author?: Maybe<UserWhereInput>;
  comments_every?: Maybe<CommentWhereInput>;
  comments_some?: Maybe<CommentWhereInput>;
  comments_none?: Maybe<CommentWhereInput>;
  AND?: Maybe<PostWhereInput[] | PostWhereInput>;
  OR?: Maybe<PostWhereInput[] | PostWhereInput>;
  NOT?: Maybe<PostWhereInput[] | PostWhereInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  about?: Maybe<String>;
  about_not?: Maybe<String>;
  about_in?: Maybe<String[] | String>;
  about_not_in?: Maybe<String[] | String>;
  about_lt?: Maybe<String>;
  about_lte?: Maybe<String>;
  about_gt?: Maybe<String>;
  about_gte?: Maybe<String>;
  about_contains?: Maybe<String>;
  about_not_contains?: Maybe<String>;
  about_starts_with?: Maybe<String>;
  about_not_starts_with?: Maybe<String>;
  about_ends_with?: Maybe<String>;
  about_not_ends_with?: Maybe<String>;
  location?: Maybe<LocationWhereInput>;
  company?: Maybe<String>;
  company_not?: Maybe<String>;
  company_in?: Maybe<String[] | String>;
  company_not_in?: Maybe<String[] | String>;
  company_lt?: Maybe<String>;
  company_lte?: Maybe<String>;
  company_gt?: Maybe<String>;
  company_gte?: Maybe<String>;
  company_contains?: Maybe<String>;
  company_not_contains?: Maybe<String>;
  company_starts_with?: Maybe<String>;
  company_not_starts_with?: Maybe<String>;
  company_ends_with?: Maybe<String>;
  company_not_ends_with?: Maybe<String>;
  tac?: Maybe<Boolean>;
  tac_not?: Maybe<Boolean>;
  subscription?: Maybe<SubWhereInput>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordToken_not?: Maybe<String>;
  resetPasswordToken_in?: Maybe<String[] | String>;
  resetPasswordToken_not_in?: Maybe<String[] | String>;
  resetPasswordToken_lt?: Maybe<String>;
  resetPasswordToken_lte?: Maybe<String>;
  resetPasswordToken_gt?: Maybe<String>;
  resetPasswordToken_gte?: Maybe<String>;
  resetPasswordToken_contains?: Maybe<String>;
  resetPasswordToken_not_contains?: Maybe<String>;
  resetPasswordToken_starts_with?: Maybe<String>;
  resetPasswordToken_not_starts_with?: Maybe<String>;
  resetPasswordToken_ends_with?: Maybe<String>;
  resetPasswordToken_not_ends_with?: Maybe<String>;
  resetPasswordExpires?: Maybe<DateTimeInput>;
  resetPasswordExpires_not?: Maybe<DateTimeInput>;
  resetPasswordExpires_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  resetPasswordExpires_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  resetPasswordExpires_lt?: Maybe<DateTimeInput>;
  resetPasswordExpires_lte?: Maybe<DateTimeInput>;
  resetPasswordExpires_gt?: Maybe<DateTimeInput>;
  resetPasswordExpires_gte?: Maybe<DateTimeInput>;
  isAdmin?: Maybe<Boolean>;
  isAdmin_not?: Maybe<Boolean>;
  emailConfirmationToken?: Maybe<String>;
  emailConfirmationToken_not?: Maybe<String>;
  emailConfirmationToken_in?: Maybe<String[] | String>;
  emailConfirmationToken_not_in?: Maybe<String[] | String>;
  emailConfirmationToken_lt?: Maybe<String>;
  emailConfirmationToken_lte?: Maybe<String>;
  emailConfirmationToken_gt?: Maybe<String>;
  emailConfirmationToken_gte?: Maybe<String>;
  emailConfirmationToken_contains?: Maybe<String>;
  emailConfirmationToken_not_contains?: Maybe<String>;
  emailConfirmationToken_starts_with?: Maybe<String>;
  emailConfirmationToken_not_starts_with?: Maybe<String>;
  emailConfirmationToken_ends_with?: Maybe<String>;
  emailConfirmationToken_not_ends_with?: Maybe<String>;
  isActive?: Maybe<isActiveWhereInput>;
  joinedDate?: Maybe<DateTimeInput>;
  joinedDate_not?: Maybe<DateTimeInput>;
  joinedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  joinedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  joinedDate_lt?: Maybe<DateTimeInput>;
  joinedDate_lte?: Maybe<DateTimeInput>;
  joinedDate_gt?: Maybe<DateTimeInput>;
  joinedDate_gte?: Maybe<DateTimeInput>;
  post_every?: Maybe<PostWhereInput>;
  post_some?: Maybe<PostWhereInput>;
  post_none?: Maybe<PostWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface LocationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  town?: Maybe<String>;
  town_not?: Maybe<String>;
  town_in?: Maybe<String[] | String>;
  town_not_in?: Maybe<String[] | String>;
  town_lt?: Maybe<String>;
  town_lte?: Maybe<String>;
  town_gt?: Maybe<String>;
  town_gte?: Maybe<String>;
  town_contains?: Maybe<String>;
  town_not_contains?: Maybe<String>;
  town_starts_with?: Maybe<String>;
  town_not_starts_with?: Maybe<String>;
  town_ends_with?: Maybe<String>;
  town_not_ends_with?: Maybe<String>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  AND?: Maybe<LocationWhereInput[] | LocationWhereInput>;
  OR?: Maybe<LocationWhereInput[] | LocationWhereInput>;
  NOT?: Maybe<LocationWhereInput[] | LocationWhereInput>;
}

export interface SubWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  plan?: Maybe<String>;
  plan_not?: Maybe<String>;
  plan_in?: Maybe<String[] | String>;
  plan_not_in?: Maybe<String[] | String>;
  plan_lt?: Maybe<String>;
  plan_lte?: Maybe<String>;
  plan_gt?: Maybe<String>;
  plan_gte?: Maybe<String>;
  plan_contains?: Maybe<String>;
  plan_not_contains?: Maybe<String>;
  plan_starts_with?: Maybe<String>;
  plan_not_starts_with?: Maybe<String>;
  plan_ends_with?: Maybe<String>;
  plan_not_ends_with?: Maybe<String>;
  days?: Maybe<Int>;
  days_not?: Maybe<Int>;
  days_in?: Maybe<Int[] | Int>;
  days_not_in?: Maybe<Int[] | Int>;
  days_lt?: Maybe<Int>;
  days_lte?: Maybe<Int>;
  days_gt?: Maybe<Int>;
  days_gte?: Maybe<Int>;
  startedIn?: Maybe<DateTimeInput>;
  startedIn_not?: Maybe<DateTimeInput>;
  startedIn_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startedIn_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startedIn_lt?: Maybe<DateTimeInput>;
  startedIn_lte?: Maybe<DateTimeInput>;
  startedIn_gt?: Maybe<DateTimeInput>;
  startedIn_gte?: Maybe<DateTimeInput>;
  expiresIn?: Maybe<DateTimeInput>;
  expiresIn_not?: Maybe<DateTimeInput>;
  expiresIn_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiresIn_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiresIn_lt?: Maybe<DateTimeInput>;
  expiresIn_lte?: Maybe<DateTimeInput>;
  expiresIn_gt?: Maybe<DateTimeInput>;
  expiresIn_gte?: Maybe<DateTimeInput>;
  isActive?: Maybe<Boolean>;
  isActive_not?: Maybe<Boolean>;
  AND?: Maybe<SubWhereInput[] | SubWhereInput>;
  OR?: Maybe<SubWhereInput[] | SubWhereInput>;
  NOT?: Maybe<SubWhereInput[] | SubWhereInput>;
}

export interface isActiveWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  status?: Maybe<Boolean>;
  status_not?: Maybe<Boolean>;
  activedOn?: Maybe<DateTimeInput>;
  activedOn_not?: Maybe<DateTimeInput>;
  activedOn_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  activedOn_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  activedOn_lt?: Maybe<DateTimeInput>;
  activedOn_lte?: Maybe<DateTimeInput>;
  activedOn_gt?: Maybe<DateTimeInput>;
  activedOn_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<isActiveWhereInput[] | isActiveWhereInput>;
  OR?: Maybe<isActiveWhereInput[] | isActiveWhereInput>;
  NOT?: Maybe<isActiveWhereInput[] | isActiveWhereInput>;
}

export interface CommentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  body?: Maybe<String>;
  body_not?: Maybe<String>;
  body_in?: Maybe<String[] | String>;
  body_not_in?: Maybe<String[] | String>;
  body_lt?: Maybe<String>;
  body_lte?: Maybe<String>;
  body_gt?: Maybe<String>;
  body_gte?: Maybe<String>;
  body_contains?: Maybe<String>;
  body_not_contains?: Maybe<String>;
  body_starts_with?: Maybe<String>;
  body_not_starts_with?: Maybe<String>;
  body_ends_with?: Maybe<String>;
  body_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  author?: Maybe<UserWhereInput>;
  AND?: Maybe<CommentWhereInput[] | CommentWhereInput>;
  OR?: Maybe<CommentWhereInput[] | CommentWhereInput>;
  NOT?: Maybe<CommentWhereInput[] | CommentWhereInput>;
}

export type ContentsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type CounselWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type FaqWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type IssuesWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type JudgeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type LocationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type PostWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type QuestionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type RatiosWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ReportWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type SubWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export type VolWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type isActiveWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CasesCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  likes?: Maybe<Int>;
  appellant?: Maybe<String>;
  respondent?: Maybe<String>;
  suit_no?: Maybe<String>;
  page_no?: Maybe<String>;
  State?: Maybe<String>;
  cat?: Maybe<String>;
  judges?: Maybe<JudgeCreateManyWithoutCasesInput>;
  counsel?: Maybe<CounselCreateOneInput>;
  vol: VolCreateOneWithoutCasesInput;
  appeal?: Maybe<String>;
  court?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  catchwords?: Maybe<String>;
  issues?: Maybe<IssuesCreateOneInput>;
  summary?: Maybe<String>;
  judgement?: Maybe<String>;
  cited?: Maybe<String>;
  books_cited?: Maybe<String>;
  determinations?: Maybe<String>;
}

export interface JudgeCreateManyWithoutCasesInput {
  create?: Maybe<JudgeCreateWithoutCasesInput[] | JudgeCreateWithoutCasesInput>;
  connect?: Maybe<JudgeWhereUniqueInput[] | JudgeWhereUniqueInput>;
}

export interface JudgeCreateWithoutCasesInput {
  id?: Maybe<ID_Input>;
  name: String;
  title: String;
  image: String;
  bio: String;
  dob?: Maybe<DateTimeInput>;
  State: String;
  ctb: String;
  education: String;
  likes?: Maybe<Int>;
  remark: String;
}

export interface CounselCreateOneInput {
  create?: Maybe<CounselCreateInput>;
  connect?: Maybe<CounselWhereUniqueInput>;
}

export interface CounselCreateInput {
  id?: Maybe<ID_Input>;
  appellant?: Maybe<String>;
  respondent?: Maybe<String>;
}

export interface VolCreateOneWithoutCasesInput {
  create?: Maybe<VolCreateWithoutCasesInput>;
  connect?: Maybe<VolWhereUniqueInput>;
}

export interface VolCreateWithoutCasesInput {
  id?: Maybe<ID_Input>;
  part_no: Int;
  year: Int;
  report?: Maybe<ReportCreateOneWithoutVolsInput>;
}

export interface ReportCreateOneWithoutVolsInput {
  create?: Maybe<ReportCreateWithoutVolsInput>;
  connect?: Maybe<ReportWhereUniqueInput>;
}

export interface ReportCreateWithoutVolsInput {
  id?: Maybe<ID_Input>;
  year?: Maybe<Int>;
}

export interface IssuesCreateOneInput {
  create?: Maybe<IssuesCreateInput>;
  connect?: Maybe<IssuesWhereUniqueInput>;
}

export interface IssuesCreateInput {
  id?: Maybe<ID_Input>;
  status?: Maybe<String>;
  ratios?: Maybe<RatiosCreateManyInput>;
}

export interface RatiosCreateManyInput {
  create?: Maybe<RatiosCreateInput[] | RatiosCreateInput>;
  connect?: Maybe<RatiosWhereUniqueInput[] | RatiosWhereUniqueInput>;
}

export interface RatiosCreateInput {
  id?: Maybe<ID_Input>;
  heading?: Maybe<String>;
  contents?: Maybe<ContentsCreateOneInput>;
}

export interface ContentsCreateOneInput {
  create?: Maybe<ContentsCreateInput>;
  connect?: Maybe<ContentsWhereUniqueInput>;
}

export interface ContentsCreateInput {
  id?: Maybe<ID_Input>;
  quoted?: Maybe<JudgeCreateOneInput>;
  ref?: Maybe<String>;
  body?: Maybe<String>;
}

export interface JudgeCreateOneInput {
  create?: Maybe<JudgeCreateInput>;
  connect?: Maybe<JudgeWhereUniqueInput>;
}

export interface JudgeCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  title: String;
  image: String;
  bio: String;
  dob?: Maybe<DateTimeInput>;
  State: String;
  ctb: String;
  education: String;
  likes?: Maybe<Int>;
  remark: String;
  cases?: Maybe<CasesCreateManyWithoutJudgesInput>;
}

export interface CasesCreateManyWithoutJudgesInput {
  create?: Maybe<
    CasesCreateWithoutJudgesInput[] | CasesCreateWithoutJudgesInput
  >;
  connect?: Maybe<CasesWhereUniqueInput[] | CasesWhereUniqueInput>;
}

export interface CasesCreateWithoutJudgesInput {
  id?: Maybe<ID_Input>;
  title: String;
  likes?: Maybe<Int>;
  appellant?: Maybe<String>;
  respondent?: Maybe<String>;
  suit_no?: Maybe<String>;
  page_no?: Maybe<String>;
  State?: Maybe<String>;
  cat?: Maybe<String>;
  counsel?: Maybe<CounselCreateOneInput>;
  vol: VolCreateOneWithoutCasesInput;
  appeal?: Maybe<String>;
  court?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  catchwords?: Maybe<String>;
  issues?: Maybe<IssuesCreateOneInput>;
  summary?: Maybe<String>;
  judgement?: Maybe<String>;
  cited?: Maybe<String>;
  books_cited?: Maybe<String>;
  determinations?: Maybe<String>;
}

export interface CasesUpdateInput {
  title?: Maybe<String>;
  likes?: Maybe<Int>;
  appellant?: Maybe<String>;
  respondent?: Maybe<String>;
  suit_no?: Maybe<String>;
  page_no?: Maybe<String>;
  State?: Maybe<String>;
  cat?: Maybe<String>;
  judges?: Maybe<JudgeUpdateManyWithoutCasesInput>;
  counsel?: Maybe<CounselUpdateOneInput>;
  vol?: Maybe<VolUpdateOneRequiredWithoutCasesInput>;
  appeal?: Maybe<String>;
  court?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  catchwords?: Maybe<String>;
  issues?: Maybe<IssuesUpdateOneInput>;
  summary?: Maybe<String>;
  judgement?: Maybe<String>;
  cited?: Maybe<String>;
  books_cited?: Maybe<String>;
  determinations?: Maybe<String>;
}

export interface JudgeUpdateManyWithoutCasesInput {
  create?: Maybe<JudgeCreateWithoutCasesInput[] | JudgeCreateWithoutCasesInput>;
  delete?: Maybe<JudgeWhereUniqueInput[] | JudgeWhereUniqueInput>;
  connect?: Maybe<JudgeWhereUniqueInput[] | JudgeWhereUniqueInput>;
  set?: Maybe<JudgeWhereUniqueInput[] | JudgeWhereUniqueInput>;
  disconnect?: Maybe<JudgeWhereUniqueInput[] | JudgeWhereUniqueInput>;
  update?: Maybe<
    | JudgeUpdateWithWhereUniqueWithoutCasesInput[]
    | JudgeUpdateWithWhereUniqueWithoutCasesInput
  >;
  upsert?: Maybe<
    | JudgeUpsertWithWhereUniqueWithoutCasesInput[]
    | JudgeUpsertWithWhereUniqueWithoutCasesInput
  >;
  deleteMany?: Maybe<JudgeScalarWhereInput[] | JudgeScalarWhereInput>;
  updateMany?: Maybe<
    JudgeUpdateManyWithWhereNestedInput[] | JudgeUpdateManyWithWhereNestedInput
  >;
}

export interface JudgeUpdateWithWhereUniqueWithoutCasesInput {
  where: JudgeWhereUniqueInput;
  data: JudgeUpdateWithoutCasesDataInput;
}

export interface JudgeUpdateWithoutCasesDataInput {
  name?: Maybe<String>;
  title?: Maybe<String>;
  image?: Maybe<String>;
  bio?: Maybe<String>;
  dob?: Maybe<DateTimeInput>;
  State?: Maybe<String>;
  ctb?: Maybe<String>;
  education?: Maybe<String>;
  likes?: Maybe<Int>;
  remark?: Maybe<String>;
}

export interface JudgeUpsertWithWhereUniqueWithoutCasesInput {
  where: JudgeWhereUniqueInput;
  update: JudgeUpdateWithoutCasesDataInput;
  create: JudgeCreateWithoutCasesInput;
}

export interface JudgeScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  bio?: Maybe<String>;
  bio_not?: Maybe<String>;
  bio_in?: Maybe<String[] | String>;
  bio_not_in?: Maybe<String[] | String>;
  bio_lt?: Maybe<String>;
  bio_lte?: Maybe<String>;
  bio_gt?: Maybe<String>;
  bio_gte?: Maybe<String>;
  bio_contains?: Maybe<String>;
  bio_not_contains?: Maybe<String>;
  bio_starts_with?: Maybe<String>;
  bio_not_starts_with?: Maybe<String>;
  bio_ends_with?: Maybe<String>;
  bio_not_ends_with?: Maybe<String>;
  dob?: Maybe<DateTimeInput>;
  dob_not?: Maybe<DateTimeInput>;
  dob_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dob_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dob_lt?: Maybe<DateTimeInput>;
  dob_lte?: Maybe<DateTimeInput>;
  dob_gt?: Maybe<DateTimeInput>;
  dob_gte?: Maybe<DateTimeInput>;
  State?: Maybe<String>;
  State_not?: Maybe<String>;
  State_in?: Maybe<String[] | String>;
  State_not_in?: Maybe<String[] | String>;
  State_lt?: Maybe<String>;
  State_lte?: Maybe<String>;
  State_gt?: Maybe<String>;
  State_gte?: Maybe<String>;
  State_contains?: Maybe<String>;
  State_not_contains?: Maybe<String>;
  State_starts_with?: Maybe<String>;
  State_not_starts_with?: Maybe<String>;
  State_ends_with?: Maybe<String>;
  State_not_ends_with?: Maybe<String>;
  ctb?: Maybe<String>;
  ctb_not?: Maybe<String>;
  ctb_in?: Maybe<String[] | String>;
  ctb_not_in?: Maybe<String[] | String>;
  ctb_lt?: Maybe<String>;
  ctb_lte?: Maybe<String>;
  ctb_gt?: Maybe<String>;
  ctb_gte?: Maybe<String>;
  ctb_contains?: Maybe<String>;
  ctb_not_contains?: Maybe<String>;
  ctb_starts_with?: Maybe<String>;
  ctb_not_starts_with?: Maybe<String>;
  ctb_ends_with?: Maybe<String>;
  ctb_not_ends_with?: Maybe<String>;
  education?: Maybe<String>;
  education_not?: Maybe<String>;
  education_in?: Maybe<String[] | String>;
  education_not_in?: Maybe<String[] | String>;
  education_lt?: Maybe<String>;
  education_lte?: Maybe<String>;
  education_gt?: Maybe<String>;
  education_gte?: Maybe<String>;
  education_contains?: Maybe<String>;
  education_not_contains?: Maybe<String>;
  education_starts_with?: Maybe<String>;
  education_not_starts_with?: Maybe<String>;
  education_ends_with?: Maybe<String>;
  education_not_ends_with?: Maybe<String>;
  likes?: Maybe<Int>;
  likes_not?: Maybe<Int>;
  likes_in?: Maybe<Int[] | Int>;
  likes_not_in?: Maybe<Int[] | Int>;
  likes_lt?: Maybe<Int>;
  likes_lte?: Maybe<Int>;
  likes_gt?: Maybe<Int>;
  likes_gte?: Maybe<Int>;
  remark?: Maybe<String>;
  remark_not?: Maybe<String>;
  remark_in?: Maybe<String[] | String>;
  remark_not_in?: Maybe<String[] | String>;
  remark_lt?: Maybe<String>;
  remark_lte?: Maybe<String>;
  remark_gt?: Maybe<String>;
  remark_gte?: Maybe<String>;
  remark_contains?: Maybe<String>;
  remark_not_contains?: Maybe<String>;
  remark_starts_with?: Maybe<String>;
  remark_not_starts_with?: Maybe<String>;
  remark_ends_with?: Maybe<String>;
  remark_not_ends_with?: Maybe<String>;
  AND?: Maybe<JudgeScalarWhereInput[] | JudgeScalarWhereInput>;
  OR?: Maybe<JudgeScalarWhereInput[] | JudgeScalarWhereInput>;
  NOT?: Maybe<JudgeScalarWhereInput[] | JudgeScalarWhereInput>;
}

export interface JudgeUpdateManyWithWhereNestedInput {
  where: JudgeScalarWhereInput;
  data: JudgeUpdateManyDataInput;
}

export interface JudgeUpdateManyDataInput {
  name?: Maybe<String>;
  title?: Maybe<String>;
  image?: Maybe<String>;
  bio?: Maybe<String>;
  dob?: Maybe<DateTimeInput>;
  State?: Maybe<String>;
  ctb?: Maybe<String>;
  education?: Maybe<String>;
  likes?: Maybe<Int>;
  remark?: Maybe<String>;
}

export interface CounselUpdateOneInput {
  create?: Maybe<CounselCreateInput>;
  update?: Maybe<CounselUpdateDataInput>;
  upsert?: Maybe<CounselUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CounselWhereUniqueInput>;
}

export interface CounselUpdateDataInput {
  appellant?: Maybe<String>;
  respondent?: Maybe<String>;
}

export interface CounselUpsertNestedInput {
  update: CounselUpdateDataInput;
  create: CounselCreateInput;
}

export interface VolUpdateOneRequiredWithoutCasesInput {
  create?: Maybe<VolCreateWithoutCasesInput>;
  update?: Maybe<VolUpdateWithoutCasesDataInput>;
  upsert?: Maybe<VolUpsertWithoutCasesInput>;
  connect?: Maybe<VolWhereUniqueInput>;
}

export interface VolUpdateWithoutCasesDataInput {
  part_no?: Maybe<Int>;
  year?: Maybe<Int>;
  report?: Maybe<ReportUpdateOneWithoutVolsInput>;
}

export interface ReportUpdateOneWithoutVolsInput {
  create?: Maybe<ReportCreateWithoutVolsInput>;
  update?: Maybe<ReportUpdateWithoutVolsDataInput>;
  upsert?: Maybe<ReportUpsertWithoutVolsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ReportWhereUniqueInput>;
}

export interface ReportUpdateWithoutVolsDataInput {
  year?: Maybe<Int>;
}

export interface ReportUpsertWithoutVolsInput {
  update: ReportUpdateWithoutVolsDataInput;
  create: ReportCreateWithoutVolsInput;
}

export interface VolUpsertWithoutCasesInput {
  update: VolUpdateWithoutCasesDataInput;
  create: VolCreateWithoutCasesInput;
}

export interface IssuesUpdateOneInput {
  create?: Maybe<IssuesCreateInput>;
  update?: Maybe<IssuesUpdateDataInput>;
  upsert?: Maybe<IssuesUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<IssuesWhereUniqueInput>;
}

export interface IssuesUpdateDataInput {
  status?: Maybe<String>;
  ratios?: Maybe<RatiosUpdateManyInput>;
}

export interface RatiosUpdateManyInput {
  create?: Maybe<RatiosCreateInput[] | RatiosCreateInput>;
  update?: Maybe<
    | RatiosUpdateWithWhereUniqueNestedInput[]
    | RatiosUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | RatiosUpsertWithWhereUniqueNestedInput[]
    | RatiosUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<RatiosWhereUniqueInput[] | RatiosWhereUniqueInput>;
  connect?: Maybe<RatiosWhereUniqueInput[] | RatiosWhereUniqueInput>;
  set?: Maybe<RatiosWhereUniqueInput[] | RatiosWhereUniqueInput>;
  disconnect?: Maybe<RatiosWhereUniqueInput[] | RatiosWhereUniqueInput>;
  deleteMany?: Maybe<RatiosScalarWhereInput[] | RatiosScalarWhereInput>;
  updateMany?: Maybe<
    | RatiosUpdateManyWithWhereNestedInput[]
    | RatiosUpdateManyWithWhereNestedInput
  >;
}

export interface RatiosUpdateWithWhereUniqueNestedInput {
  where: RatiosWhereUniqueInput;
  data: RatiosUpdateDataInput;
}

export interface RatiosUpdateDataInput {
  heading?: Maybe<String>;
  contents?: Maybe<ContentsUpdateOneInput>;
}

export interface ContentsUpdateOneInput {
  create?: Maybe<ContentsCreateInput>;
  update?: Maybe<ContentsUpdateDataInput>;
  upsert?: Maybe<ContentsUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ContentsWhereUniqueInput>;
}

export interface ContentsUpdateDataInput {
  quoted?: Maybe<JudgeUpdateOneInput>;
  ref?: Maybe<String>;
  body?: Maybe<String>;
}

export interface JudgeUpdateOneInput {
  create?: Maybe<JudgeCreateInput>;
  update?: Maybe<JudgeUpdateDataInput>;
  upsert?: Maybe<JudgeUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<JudgeWhereUniqueInput>;
}

export interface JudgeUpdateDataInput {
  name?: Maybe<String>;
  title?: Maybe<String>;
  image?: Maybe<String>;
  bio?: Maybe<String>;
  dob?: Maybe<DateTimeInput>;
  State?: Maybe<String>;
  ctb?: Maybe<String>;
  education?: Maybe<String>;
  likes?: Maybe<Int>;
  remark?: Maybe<String>;
  cases?: Maybe<CasesUpdateManyWithoutJudgesInput>;
}

export interface CasesUpdateManyWithoutJudgesInput {
  create?: Maybe<
    CasesCreateWithoutJudgesInput[] | CasesCreateWithoutJudgesInput
  >;
  delete?: Maybe<CasesWhereUniqueInput[] | CasesWhereUniqueInput>;
  connect?: Maybe<CasesWhereUniqueInput[] | CasesWhereUniqueInput>;
  set?: Maybe<CasesWhereUniqueInput[] | CasesWhereUniqueInput>;
  disconnect?: Maybe<CasesWhereUniqueInput[] | CasesWhereUniqueInput>;
  update?: Maybe<
    | CasesUpdateWithWhereUniqueWithoutJudgesInput[]
    | CasesUpdateWithWhereUniqueWithoutJudgesInput
  >;
  upsert?: Maybe<
    | CasesUpsertWithWhereUniqueWithoutJudgesInput[]
    | CasesUpsertWithWhereUniqueWithoutJudgesInput
  >;
  deleteMany?: Maybe<CasesScalarWhereInput[] | CasesScalarWhereInput>;
  updateMany?: Maybe<
    CasesUpdateManyWithWhereNestedInput[] | CasesUpdateManyWithWhereNestedInput
  >;
}

export interface CasesUpdateWithWhereUniqueWithoutJudgesInput {
  where: CasesWhereUniqueInput;
  data: CasesUpdateWithoutJudgesDataInput;
}

export interface CasesUpdateWithoutJudgesDataInput {
  title?: Maybe<String>;
  likes?: Maybe<Int>;
  appellant?: Maybe<String>;
  respondent?: Maybe<String>;
  suit_no?: Maybe<String>;
  page_no?: Maybe<String>;
  State?: Maybe<String>;
  cat?: Maybe<String>;
  counsel?: Maybe<CounselUpdateOneInput>;
  vol?: Maybe<VolUpdateOneRequiredWithoutCasesInput>;
  appeal?: Maybe<String>;
  court?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  catchwords?: Maybe<String>;
  issues?: Maybe<IssuesUpdateOneInput>;
  summary?: Maybe<String>;
  judgement?: Maybe<String>;
  cited?: Maybe<String>;
  books_cited?: Maybe<String>;
  determinations?: Maybe<String>;
}

export interface CasesUpsertWithWhereUniqueWithoutJudgesInput {
  where: CasesWhereUniqueInput;
  update: CasesUpdateWithoutJudgesDataInput;
  create: CasesCreateWithoutJudgesInput;
}

export interface CasesScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  likes?: Maybe<Int>;
  likes_not?: Maybe<Int>;
  likes_in?: Maybe<Int[] | Int>;
  likes_not_in?: Maybe<Int[] | Int>;
  likes_lt?: Maybe<Int>;
  likes_lte?: Maybe<Int>;
  likes_gt?: Maybe<Int>;
  likes_gte?: Maybe<Int>;
  appellant?: Maybe<String>;
  appellant_not?: Maybe<String>;
  appellant_in?: Maybe<String[] | String>;
  appellant_not_in?: Maybe<String[] | String>;
  appellant_lt?: Maybe<String>;
  appellant_lte?: Maybe<String>;
  appellant_gt?: Maybe<String>;
  appellant_gte?: Maybe<String>;
  appellant_contains?: Maybe<String>;
  appellant_not_contains?: Maybe<String>;
  appellant_starts_with?: Maybe<String>;
  appellant_not_starts_with?: Maybe<String>;
  appellant_ends_with?: Maybe<String>;
  appellant_not_ends_with?: Maybe<String>;
  respondent?: Maybe<String>;
  respondent_not?: Maybe<String>;
  respondent_in?: Maybe<String[] | String>;
  respondent_not_in?: Maybe<String[] | String>;
  respondent_lt?: Maybe<String>;
  respondent_lte?: Maybe<String>;
  respondent_gt?: Maybe<String>;
  respondent_gte?: Maybe<String>;
  respondent_contains?: Maybe<String>;
  respondent_not_contains?: Maybe<String>;
  respondent_starts_with?: Maybe<String>;
  respondent_not_starts_with?: Maybe<String>;
  respondent_ends_with?: Maybe<String>;
  respondent_not_ends_with?: Maybe<String>;
  suit_no?: Maybe<String>;
  suit_no_not?: Maybe<String>;
  suit_no_in?: Maybe<String[] | String>;
  suit_no_not_in?: Maybe<String[] | String>;
  suit_no_lt?: Maybe<String>;
  suit_no_lte?: Maybe<String>;
  suit_no_gt?: Maybe<String>;
  suit_no_gte?: Maybe<String>;
  suit_no_contains?: Maybe<String>;
  suit_no_not_contains?: Maybe<String>;
  suit_no_starts_with?: Maybe<String>;
  suit_no_not_starts_with?: Maybe<String>;
  suit_no_ends_with?: Maybe<String>;
  suit_no_not_ends_with?: Maybe<String>;
  page_no?: Maybe<String>;
  page_no_not?: Maybe<String>;
  page_no_in?: Maybe<String[] | String>;
  page_no_not_in?: Maybe<String[] | String>;
  page_no_lt?: Maybe<String>;
  page_no_lte?: Maybe<String>;
  page_no_gt?: Maybe<String>;
  page_no_gte?: Maybe<String>;
  page_no_contains?: Maybe<String>;
  page_no_not_contains?: Maybe<String>;
  page_no_starts_with?: Maybe<String>;
  page_no_not_starts_with?: Maybe<String>;
  page_no_ends_with?: Maybe<String>;
  page_no_not_ends_with?: Maybe<String>;
  State?: Maybe<String>;
  State_not?: Maybe<String>;
  State_in?: Maybe<String[] | String>;
  State_not_in?: Maybe<String[] | String>;
  State_lt?: Maybe<String>;
  State_lte?: Maybe<String>;
  State_gt?: Maybe<String>;
  State_gte?: Maybe<String>;
  State_contains?: Maybe<String>;
  State_not_contains?: Maybe<String>;
  State_starts_with?: Maybe<String>;
  State_not_starts_with?: Maybe<String>;
  State_ends_with?: Maybe<String>;
  State_not_ends_with?: Maybe<String>;
  cat?: Maybe<String>;
  cat_not?: Maybe<String>;
  cat_in?: Maybe<String[] | String>;
  cat_not_in?: Maybe<String[] | String>;
  cat_lt?: Maybe<String>;
  cat_lte?: Maybe<String>;
  cat_gt?: Maybe<String>;
  cat_gte?: Maybe<String>;
  cat_contains?: Maybe<String>;
  cat_not_contains?: Maybe<String>;
  cat_starts_with?: Maybe<String>;
  cat_not_starts_with?: Maybe<String>;
  cat_ends_with?: Maybe<String>;
  cat_not_ends_with?: Maybe<String>;
  appeal?: Maybe<String>;
  appeal_not?: Maybe<String>;
  appeal_in?: Maybe<String[] | String>;
  appeal_not_in?: Maybe<String[] | String>;
  appeal_lt?: Maybe<String>;
  appeal_lte?: Maybe<String>;
  appeal_gt?: Maybe<String>;
  appeal_gte?: Maybe<String>;
  appeal_contains?: Maybe<String>;
  appeal_not_contains?: Maybe<String>;
  appeal_starts_with?: Maybe<String>;
  appeal_not_starts_with?: Maybe<String>;
  appeal_ends_with?: Maybe<String>;
  appeal_not_ends_with?: Maybe<String>;
  court?: Maybe<String>;
  court_not?: Maybe<String>;
  court_in?: Maybe<String[] | String>;
  court_not_in?: Maybe<String[] | String>;
  court_lt?: Maybe<String>;
  court_lte?: Maybe<String>;
  court_gt?: Maybe<String>;
  court_gte?: Maybe<String>;
  court_contains?: Maybe<String>;
  court_not_contains?: Maybe<String>;
  court_starts_with?: Maybe<String>;
  court_not_starts_with?: Maybe<String>;
  court_ends_with?: Maybe<String>;
  court_not_ends_with?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  catchwords?: Maybe<String>;
  catchwords_not?: Maybe<String>;
  catchwords_in?: Maybe<String[] | String>;
  catchwords_not_in?: Maybe<String[] | String>;
  catchwords_lt?: Maybe<String>;
  catchwords_lte?: Maybe<String>;
  catchwords_gt?: Maybe<String>;
  catchwords_gte?: Maybe<String>;
  catchwords_contains?: Maybe<String>;
  catchwords_not_contains?: Maybe<String>;
  catchwords_starts_with?: Maybe<String>;
  catchwords_not_starts_with?: Maybe<String>;
  catchwords_ends_with?: Maybe<String>;
  catchwords_not_ends_with?: Maybe<String>;
  summary?: Maybe<String>;
  summary_not?: Maybe<String>;
  summary_in?: Maybe<String[] | String>;
  summary_not_in?: Maybe<String[] | String>;
  summary_lt?: Maybe<String>;
  summary_lte?: Maybe<String>;
  summary_gt?: Maybe<String>;
  summary_gte?: Maybe<String>;
  summary_contains?: Maybe<String>;
  summary_not_contains?: Maybe<String>;
  summary_starts_with?: Maybe<String>;
  summary_not_starts_with?: Maybe<String>;
  summary_ends_with?: Maybe<String>;
  summary_not_ends_with?: Maybe<String>;
  judgement?: Maybe<String>;
  judgement_not?: Maybe<String>;
  judgement_in?: Maybe<String[] | String>;
  judgement_not_in?: Maybe<String[] | String>;
  judgement_lt?: Maybe<String>;
  judgement_lte?: Maybe<String>;
  judgement_gt?: Maybe<String>;
  judgement_gte?: Maybe<String>;
  judgement_contains?: Maybe<String>;
  judgement_not_contains?: Maybe<String>;
  judgement_starts_with?: Maybe<String>;
  judgement_not_starts_with?: Maybe<String>;
  judgement_ends_with?: Maybe<String>;
  judgement_not_ends_with?: Maybe<String>;
  cited?: Maybe<String>;
  cited_not?: Maybe<String>;
  cited_in?: Maybe<String[] | String>;
  cited_not_in?: Maybe<String[] | String>;
  cited_lt?: Maybe<String>;
  cited_lte?: Maybe<String>;
  cited_gt?: Maybe<String>;
  cited_gte?: Maybe<String>;
  cited_contains?: Maybe<String>;
  cited_not_contains?: Maybe<String>;
  cited_starts_with?: Maybe<String>;
  cited_not_starts_with?: Maybe<String>;
  cited_ends_with?: Maybe<String>;
  cited_not_ends_with?: Maybe<String>;
  books_cited?: Maybe<String>;
  books_cited_not?: Maybe<String>;
  books_cited_in?: Maybe<String[] | String>;
  books_cited_not_in?: Maybe<String[] | String>;
  books_cited_lt?: Maybe<String>;
  books_cited_lte?: Maybe<String>;
  books_cited_gt?: Maybe<String>;
  books_cited_gte?: Maybe<String>;
  books_cited_contains?: Maybe<String>;
  books_cited_not_contains?: Maybe<String>;
  books_cited_starts_with?: Maybe<String>;
  books_cited_not_starts_with?: Maybe<String>;
  books_cited_ends_with?: Maybe<String>;
  books_cited_not_ends_with?: Maybe<String>;
  determinations?: Maybe<String>;
  determinations_not?: Maybe<String>;
  determinations_in?: Maybe<String[] | String>;
  determinations_not_in?: Maybe<String[] | String>;
  determinations_lt?: Maybe<String>;
  determinations_lte?: Maybe<String>;
  determinations_gt?: Maybe<String>;
  determinations_gte?: Maybe<String>;
  determinations_contains?: Maybe<String>;
  determinations_not_contains?: Maybe<String>;
  determinations_starts_with?: Maybe<String>;
  determinations_not_starts_with?: Maybe<String>;
  determinations_ends_with?: Maybe<String>;
  determinations_not_ends_with?: Maybe<String>;
  AND?: Maybe<CasesScalarWhereInput[] | CasesScalarWhereInput>;
  OR?: Maybe<CasesScalarWhereInput[] | CasesScalarWhereInput>;
  NOT?: Maybe<CasesScalarWhereInput[] | CasesScalarWhereInput>;
}

export interface CasesUpdateManyWithWhereNestedInput {
  where: CasesScalarWhereInput;
  data: CasesUpdateManyDataInput;
}

export interface CasesUpdateManyDataInput {
  title?: Maybe<String>;
  likes?: Maybe<Int>;
  appellant?: Maybe<String>;
  respondent?: Maybe<String>;
  suit_no?: Maybe<String>;
  page_no?: Maybe<String>;
  State?: Maybe<String>;
  cat?: Maybe<String>;
  appeal?: Maybe<String>;
  court?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  catchwords?: Maybe<String>;
  summary?: Maybe<String>;
  judgement?: Maybe<String>;
  cited?: Maybe<String>;
  books_cited?: Maybe<String>;
  determinations?: Maybe<String>;
}

export interface JudgeUpsertNestedInput {
  update: JudgeUpdateDataInput;
  create: JudgeCreateInput;
}

export interface ContentsUpsertNestedInput {
  update: ContentsUpdateDataInput;
  create: ContentsCreateInput;
}

export interface RatiosUpsertWithWhereUniqueNestedInput {
  where: RatiosWhereUniqueInput;
  update: RatiosUpdateDataInput;
  create: RatiosCreateInput;
}

export interface RatiosScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  heading?: Maybe<String>;
  heading_not?: Maybe<String>;
  heading_in?: Maybe<String[] | String>;
  heading_not_in?: Maybe<String[] | String>;
  heading_lt?: Maybe<String>;
  heading_lte?: Maybe<String>;
  heading_gt?: Maybe<String>;
  heading_gte?: Maybe<String>;
  heading_contains?: Maybe<String>;
  heading_not_contains?: Maybe<String>;
  heading_starts_with?: Maybe<String>;
  heading_not_starts_with?: Maybe<String>;
  heading_ends_with?: Maybe<String>;
  heading_not_ends_with?: Maybe<String>;
  AND?: Maybe<RatiosScalarWhereInput[] | RatiosScalarWhereInput>;
  OR?: Maybe<RatiosScalarWhereInput[] | RatiosScalarWhereInput>;
  NOT?: Maybe<RatiosScalarWhereInput[] | RatiosScalarWhereInput>;
}

export interface RatiosUpdateManyWithWhereNestedInput {
  where: RatiosScalarWhereInput;
  data: RatiosUpdateManyDataInput;
}

export interface RatiosUpdateManyDataInput {
  heading?: Maybe<String>;
}

export interface IssuesUpsertNestedInput {
  update: IssuesUpdateDataInput;
  create: IssuesCreateInput;
}

export interface CasesUpdateManyMutationInput {
  title?: Maybe<String>;
  likes?: Maybe<Int>;
  appellant?: Maybe<String>;
  respondent?: Maybe<String>;
  suit_no?: Maybe<String>;
  page_no?: Maybe<String>;
  State?: Maybe<String>;
  cat?: Maybe<String>;
  appeal?: Maybe<String>;
  court?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  catchwords?: Maybe<String>;
  summary?: Maybe<String>;
  judgement?: Maybe<String>;
  cited?: Maybe<String>;
  books_cited?: Maybe<String>;
  determinations?: Maybe<String>;
}

export interface CategoryCreateInput {
  id?: Maybe<ID_Input>;
  category: String;
  desc: String;
  faq?: Maybe<FaqCreateManyWithoutCategoryInput>;
}

export interface FaqCreateManyWithoutCategoryInput {
  create?: Maybe<
    FaqCreateWithoutCategoryInput[] | FaqCreateWithoutCategoryInput
  >;
  connect?: Maybe<FaqWhereUniqueInput[] | FaqWhereUniqueInput>;
}

export interface FaqCreateWithoutCategoryInput {
  id?: Maybe<ID_Input>;
  title: String;
  desc: String;
  questions?: Maybe<QuestionCreateManyInput>;
}

export interface QuestionCreateManyInput {
  create?: Maybe<QuestionCreateInput[] | QuestionCreateInput>;
  connect?: Maybe<QuestionWhereUniqueInput[] | QuestionWhereUniqueInput>;
}

export interface QuestionCreateInput {
  id?: Maybe<ID_Input>;
  qns: String;
  ans: String;
}

export interface CategoryUpdateInput {
  category?: Maybe<String>;
  desc?: Maybe<String>;
  faq?: Maybe<FaqUpdateManyWithoutCategoryInput>;
}

export interface FaqUpdateManyWithoutCategoryInput {
  create?: Maybe<
    FaqCreateWithoutCategoryInput[] | FaqCreateWithoutCategoryInput
  >;
  delete?: Maybe<FaqWhereUniqueInput[] | FaqWhereUniqueInput>;
  connect?: Maybe<FaqWhereUniqueInput[] | FaqWhereUniqueInput>;
  set?: Maybe<FaqWhereUniqueInput[] | FaqWhereUniqueInput>;
  disconnect?: Maybe<FaqWhereUniqueInput[] | FaqWhereUniqueInput>;
  update?: Maybe<
    | FaqUpdateWithWhereUniqueWithoutCategoryInput[]
    | FaqUpdateWithWhereUniqueWithoutCategoryInput
  >;
  upsert?: Maybe<
    | FaqUpsertWithWhereUniqueWithoutCategoryInput[]
    | FaqUpsertWithWhereUniqueWithoutCategoryInput
  >;
  deleteMany?: Maybe<FaqScalarWhereInput[] | FaqScalarWhereInput>;
  updateMany?: Maybe<
    FaqUpdateManyWithWhereNestedInput[] | FaqUpdateManyWithWhereNestedInput
  >;
}

export interface FaqUpdateWithWhereUniqueWithoutCategoryInput {
  where: FaqWhereUniqueInput;
  data: FaqUpdateWithoutCategoryDataInput;
}

export interface FaqUpdateWithoutCategoryDataInput {
  title?: Maybe<String>;
  desc?: Maybe<String>;
  questions?: Maybe<QuestionUpdateManyInput>;
}

export interface QuestionUpdateManyInput {
  create?: Maybe<QuestionCreateInput[] | QuestionCreateInput>;
  update?: Maybe<
    | QuestionUpdateWithWhereUniqueNestedInput[]
    | QuestionUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | QuestionUpsertWithWhereUniqueNestedInput[]
    | QuestionUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<QuestionWhereUniqueInput[] | QuestionWhereUniqueInput>;
  connect?: Maybe<QuestionWhereUniqueInput[] | QuestionWhereUniqueInput>;
  set?: Maybe<QuestionWhereUniqueInput[] | QuestionWhereUniqueInput>;
  disconnect?: Maybe<QuestionWhereUniqueInput[] | QuestionWhereUniqueInput>;
  deleteMany?: Maybe<QuestionScalarWhereInput[] | QuestionScalarWhereInput>;
  updateMany?: Maybe<
    | QuestionUpdateManyWithWhereNestedInput[]
    | QuestionUpdateManyWithWhereNestedInput
  >;
}

export interface QuestionUpdateWithWhereUniqueNestedInput {
  where: QuestionWhereUniqueInput;
  data: QuestionUpdateDataInput;
}

export interface QuestionUpdateDataInput {
  qns?: Maybe<String>;
  ans?: Maybe<String>;
}

export interface QuestionUpsertWithWhereUniqueNestedInput {
  where: QuestionWhereUniqueInput;
  update: QuestionUpdateDataInput;
  create: QuestionCreateInput;
}

export interface QuestionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  qns?: Maybe<String>;
  qns_not?: Maybe<String>;
  qns_in?: Maybe<String[] | String>;
  qns_not_in?: Maybe<String[] | String>;
  qns_lt?: Maybe<String>;
  qns_lte?: Maybe<String>;
  qns_gt?: Maybe<String>;
  qns_gte?: Maybe<String>;
  qns_contains?: Maybe<String>;
  qns_not_contains?: Maybe<String>;
  qns_starts_with?: Maybe<String>;
  qns_not_starts_with?: Maybe<String>;
  qns_ends_with?: Maybe<String>;
  qns_not_ends_with?: Maybe<String>;
  ans?: Maybe<String>;
  ans_not?: Maybe<String>;
  ans_in?: Maybe<String[] | String>;
  ans_not_in?: Maybe<String[] | String>;
  ans_lt?: Maybe<String>;
  ans_lte?: Maybe<String>;
  ans_gt?: Maybe<String>;
  ans_gte?: Maybe<String>;
  ans_contains?: Maybe<String>;
  ans_not_contains?: Maybe<String>;
  ans_starts_with?: Maybe<String>;
  ans_not_starts_with?: Maybe<String>;
  ans_ends_with?: Maybe<String>;
  ans_not_ends_with?: Maybe<String>;
  AND?: Maybe<QuestionScalarWhereInput[] | QuestionScalarWhereInput>;
  OR?: Maybe<QuestionScalarWhereInput[] | QuestionScalarWhereInput>;
  NOT?: Maybe<QuestionScalarWhereInput[] | QuestionScalarWhereInput>;
}

export interface QuestionUpdateManyWithWhereNestedInput {
  where: QuestionScalarWhereInput;
  data: QuestionUpdateManyDataInput;
}

export interface QuestionUpdateManyDataInput {
  qns?: Maybe<String>;
  ans?: Maybe<String>;
}

export interface FaqUpsertWithWhereUniqueWithoutCategoryInput {
  where: FaqWhereUniqueInput;
  update: FaqUpdateWithoutCategoryDataInput;
  create: FaqCreateWithoutCategoryInput;
}

export interface FaqScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  desc?: Maybe<String>;
  desc_not?: Maybe<String>;
  desc_in?: Maybe<String[] | String>;
  desc_not_in?: Maybe<String[] | String>;
  desc_lt?: Maybe<String>;
  desc_lte?: Maybe<String>;
  desc_gt?: Maybe<String>;
  desc_gte?: Maybe<String>;
  desc_contains?: Maybe<String>;
  desc_not_contains?: Maybe<String>;
  desc_starts_with?: Maybe<String>;
  desc_not_starts_with?: Maybe<String>;
  desc_ends_with?: Maybe<String>;
  desc_not_ends_with?: Maybe<String>;
  AND?: Maybe<FaqScalarWhereInput[] | FaqScalarWhereInput>;
  OR?: Maybe<FaqScalarWhereInput[] | FaqScalarWhereInput>;
  NOT?: Maybe<FaqScalarWhereInput[] | FaqScalarWhereInput>;
}

export interface FaqUpdateManyWithWhereNestedInput {
  where: FaqScalarWhereInput;
  data: FaqUpdateManyDataInput;
}

export interface FaqUpdateManyDataInput {
  title?: Maybe<String>;
  desc?: Maybe<String>;
}

export interface CategoryUpdateManyMutationInput {
  category?: Maybe<String>;
  desc?: Maybe<String>;
}

export interface CommentCreateInput {
  id?: Maybe<ID_Input>;
  body?: Maybe<String>;
  author?: Maybe<UserCreateOneInput>;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  image?: Maybe<String>;
  username?: Maybe<String>;
  password: String;
  firstName: String;
  lastName: String;
  phone?: Maybe<String>;
  email: String;
  about?: Maybe<String>;
  location?: Maybe<LocationCreateOneInput>;
  company?: Maybe<String>;
  tac?: Maybe<Boolean>;
  subscription?: Maybe<SubCreateOneInput>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordExpires?: Maybe<DateTimeInput>;
  isAdmin?: Maybe<Boolean>;
  emailConfirmationToken?: Maybe<String>;
  isActive?: Maybe<isActiveCreateOneInput>;
  joinedDate?: Maybe<DateTimeInput>;
  post?: Maybe<PostCreateManyWithoutAuthorInput>;
}

export interface LocationCreateOneInput {
  create?: Maybe<LocationCreateInput>;
  connect?: Maybe<LocationWhereUniqueInput>;
}

export interface LocationCreateInput {
  id?: Maybe<ID_Input>;
  town?: Maybe<String>;
  state?: Maybe<String>;
}

export interface SubCreateOneInput {
  create?: Maybe<SubCreateInput>;
  connect?: Maybe<SubWhereUniqueInput>;
}

export interface SubCreateInput {
  id?: Maybe<ID_Input>;
  plan?: Maybe<String>;
  days?: Maybe<Int>;
  startedIn?: Maybe<DateTimeInput>;
  expiresIn?: Maybe<DateTimeInput>;
  isActive?: Maybe<Boolean>;
}

export interface isActiveCreateOneInput {
  create?: Maybe<isActiveCreateInput>;
  connect?: Maybe<isActiveWhereUniqueInput>;
}

export interface isActiveCreateInput {
  id?: Maybe<ID_Input>;
  status?: Maybe<Boolean>;
  activedOn?: Maybe<DateTimeInput>;
}

export interface PostCreateManyWithoutAuthorInput {
  create?: Maybe<PostCreateWithoutAuthorInput[] | PostCreateWithoutAuthorInput>;
  connect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
}

export interface PostCreateWithoutAuthorInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  category?: Maybe<String>;
  body?: Maybe<String>;
  image?: Maybe<String>;
  desc?: Maybe<String>;
  comments?: Maybe<CommentCreateManyInput>;
}

export interface CommentCreateManyInput {
  create?: Maybe<CommentCreateInput[] | CommentCreateInput>;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
}

export interface CommentUpdateInput {
  body?: Maybe<String>;
  author?: Maybe<UserUpdateOneInput>;
}

export interface UserUpdateOneInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateDataInput {
  name?: Maybe<String>;
  image?: Maybe<String>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  phone?: Maybe<String>;
  email?: Maybe<String>;
  about?: Maybe<String>;
  location?: Maybe<LocationUpdateOneInput>;
  company?: Maybe<String>;
  tac?: Maybe<Boolean>;
  subscription?: Maybe<SubUpdateOneInput>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordExpires?: Maybe<DateTimeInput>;
  isAdmin?: Maybe<Boolean>;
  emailConfirmationToken?: Maybe<String>;
  isActive?: Maybe<isActiveUpdateOneInput>;
  joinedDate?: Maybe<DateTimeInput>;
  post?: Maybe<PostUpdateManyWithoutAuthorInput>;
}

export interface LocationUpdateOneInput {
  create?: Maybe<LocationCreateInput>;
  update?: Maybe<LocationUpdateDataInput>;
  upsert?: Maybe<LocationUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<LocationWhereUniqueInput>;
}

export interface LocationUpdateDataInput {
  town?: Maybe<String>;
  state?: Maybe<String>;
}

export interface LocationUpsertNestedInput {
  update: LocationUpdateDataInput;
  create: LocationCreateInput;
}

export interface SubUpdateOneInput {
  create?: Maybe<SubCreateInput>;
  update?: Maybe<SubUpdateDataInput>;
  upsert?: Maybe<SubUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<SubWhereUniqueInput>;
}

export interface SubUpdateDataInput {
  plan?: Maybe<String>;
  days?: Maybe<Int>;
  startedIn?: Maybe<DateTimeInput>;
  expiresIn?: Maybe<DateTimeInput>;
  isActive?: Maybe<Boolean>;
}

export interface SubUpsertNestedInput {
  update: SubUpdateDataInput;
  create: SubCreateInput;
}

export interface isActiveUpdateOneInput {
  create?: Maybe<isActiveCreateInput>;
  update?: Maybe<isActiveUpdateDataInput>;
  upsert?: Maybe<isActiveUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<isActiveWhereUniqueInput>;
}

export interface isActiveUpdateDataInput {
  status?: Maybe<Boolean>;
  activedOn?: Maybe<DateTimeInput>;
}

export interface isActiveUpsertNestedInput {
  update: isActiveUpdateDataInput;
  create: isActiveCreateInput;
}

export interface PostUpdateManyWithoutAuthorInput {
  create?: Maybe<PostCreateWithoutAuthorInput[] | PostCreateWithoutAuthorInput>;
  delete?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  connect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  set?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  disconnect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  update?: Maybe<
    | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    | PostUpdateWithWhereUniqueWithoutAuthorInput
  >;
  upsert?: Maybe<
    | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    | PostUpsertWithWhereUniqueWithoutAuthorInput
  >;
  deleteMany?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
  updateMany?: Maybe<
    PostUpdateManyWithWhereNestedInput[] | PostUpdateManyWithWhereNestedInput
  >;
}

export interface PostUpdateWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput;
  data: PostUpdateWithoutAuthorDataInput;
}

export interface PostUpdateWithoutAuthorDataInput {
  title?: Maybe<String>;
  category?: Maybe<String>;
  body?: Maybe<String>;
  image?: Maybe<String>;
  desc?: Maybe<String>;
  comments?: Maybe<CommentUpdateManyInput>;
}

export interface CommentUpdateManyInput {
  create?: Maybe<CommentCreateInput[] | CommentCreateInput>;
  update?: Maybe<
    | CommentUpdateWithWhereUniqueNestedInput[]
    | CommentUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | CommentUpsertWithWhereUniqueNestedInput[]
    | CommentUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  set?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  disconnect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  deleteMany?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  updateMany?: Maybe<
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput
  >;
}

export interface CommentUpdateWithWhereUniqueNestedInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateDataInput;
}

export interface CommentUpdateDataInput {
  body?: Maybe<String>;
  author?: Maybe<UserUpdateOneInput>;
}

export interface CommentUpsertWithWhereUniqueNestedInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateDataInput;
  create: CommentCreateInput;
}

export interface CommentScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  body?: Maybe<String>;
  body_not?: Maybe<String>;
  body_in?: Maybe<String[] | String>;
  body_not_in?: Maybe<String[] | String>;
  body_lt?: Maybe<String>;
  body_lte?: Maybe<String>;
  body_gt?: Maybe<String>;
  body_gte?: Maybe<String>;
  body_contains?: Maybe<String>;
  body_not_contains?: Maybe<String>;
  body_starts_with?: Maybe<String>;
  body_not_starts_with?: Maybe<String>;
  body_ends_with?: Maybe<String>;
  body_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  OR?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  NOT?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
}

export interface CommentUpdateManyWithWhereNestedInput {
  where: CommentScalarWhereInput;
  data: CommentUpdateManyDataInput;
}

export interface CommentUpdateManyDataInput {
  body?: Maybe<String>;
}

export interface PostUpsertWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput;
  update: PostUpdateWithoutAuthorDataInput;
  create: PostCreateWithoutAuthorInput;
}

export interface PostScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  category?: Maybe<String>;
  category_not?: Maybe<String>;
  category_in?: Maybe<String[] | String>;
  category_not_in?: Maybe<String[] | String>;
  category_lt?: Maybe<String>;
  category_lte?: Maybe<String>;
  category_gt?: Maybe<String>;
  category_gte?: Maybe<String>;
  category_contains?: Maybe<String>;
  category_not_contains?: Maybe<String>;
  category_starts_with?: Maybe<String>;
  category_not_starts_with?: Maybe<String>;
  category_ends_with?: Maybe<String>;
  category_not_ends_with?: Maybe<String>;
  body?: Maybe<String>;
  body_not?: Maybe<String>;
  body_in?: Maybe<String[] | String>;
  body_not_in?: Maybe<String[] | String>;
  body_lt?: Maybe<String>;
  body_lte?: Maybe<String>;
  body_gt?: Maybe<String>;
  body_gte?: Maybe<String>;
  body_contains?: Maybe<String>;
  body_not_contains?: Maybe<String>;
  body_starts_with?: Maybe<String>;
  body_not_starts_with?: Maybe<String>;
  body_ends_with?: Maybe<String>;
  body_not_ends_with?: Maybe<String>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  desc?: Maybe<String>;
  desc_not?: Maybe<String>;
  desc_in?: Maybe<String[] | String>;
  desc_not_in?: Maybe<String[] | String>;
  desc_lt?: Maybe<String>;
  desc_lte?: Maybe<String>;
  desc_gt?: Maybe<String>;
  desc_gte?: Maybe<String>;
  desc_contains?: Maybe<String>;
  desc_not_contains?: Maybe<String>;
  desc_starts_with?: Maybe<String>;
  desc_not_starts_with?: Maybe<String>;
  desc_ends_with?: Maybe<String>;
  desc_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
  OR?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
  NOT?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
}

export interface PostUpdateManyWithWhereNestedInput {
  where: PostScalarWhereInput;
  data: PostUpdateManyDataInput;
}

export interface PostUpdateManyDataInput {
  title?: Maybe<String>;
  category?: Maybe<String>;
  body?: Maybe<String>;
  image?: Maybe<String>;
  desc?: Maybe<String>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface CommentUpdateManyMutationInput {
  body?: Maybe<String>;
}

export interface ContentsUpdateInput {
  quoted?: Maybe<JudgeUpdateOneInput>;
  ref?: Maybe<String>;
  body?: Maybe<String>;
}

export interface ContentsUpdateManyMutationInput {
  ref?: Maybe<String>;
  body?: Maybe<String>;
}

export interface CounselUpdateInput {
  appellant?: Maybe<String>;
  respondent?: Maybe<String>;
}

export interface CounselUpdateManyMutationInput {
  appellant?: Maybe<String>;
  respondent?: Maybe<String>;
}

export interface FaqCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  category: CategoryCreateOneWithoutFaqInput;
  desc: String;
  questions?: Maybe<QuestionCreateManyInput>;
}

export interface CategoryCreateOneWithoutFaqInput {
  create?: Maybe<CategoryCreateWithoutFaqInput>;
  connect?: Maybe<CategoryWhereUniqueInput>;
}

export interface CategoryCreateWithoutFaqInput {
  id?: Maybe<ID_Input>;
  category: String;
  desc: String;
}

export interface FaqUpdateInput {
  title?: Maybe<String>;
  category?: Maybe<CategoryUpdateOneRequiredWithoutFaqInput>;
  desc?: Maybe<String>;
  questions?: Maybe<QuestionUpdateManyInput>;
}

export interface CategoryUpdateOneRequiredWithoutFaqInput {
  create?: Maybe<CategoryCreateWithoutFaqInput>;
  update?: Maybe<CategoryUpdateWithoutFaqDataInput>;
  upsert?: Maybe<CategoryUpsertWithoutFaqInput>;
  connect?: Maybe<CategoryWhereUniqueInput>;
}

export interface CategoryUpdateWithoutFaqDataInput {
  category?: Maybe<String>;
  desc?: Maybe<String>;
}

export interface CategoryUpsertWithoutFaqInput {
  update: CategoryUpdateWithoutFaqDataInput;
  create: CategoryCreateWithoutFaqInput;
}

export interface FaqUpdateManyMutationInput {
  title?: Maybe<String>;
  desc?: Maybe<String>;
}

export interface IssuesUpdateInput {
  status?: Maybe<String>;
  ratios?: Maybe<RatiosUpdateManyInput>;
}

export interface IssuesUpdateManyMutationInput {
  status?: Maybe<String>;
}

export interface JudgeUpdateInput {
  name?: Maybe<String>;
  title?: Maybe<String>;
  image?: Maybe<String>;
  bio?: Maybe<String>;
  dob?: Maybe<DateTimeInput>;
  State?: Maybe<String>;
  ctb?: Maybe<String>;
  education?: Maybe<String>;
  likes?: Maybe<Int>;
  remark?: Maybe<String>;
  cases?: Maybe<CasesUpdateManyWithoutJudgesInput>;
}

export interface JudgeUpdateManyMutationInput {
  name?: Maybe<String>;
  title?: Maybe<String>;
  image?: Maybe<String>;
  bio?: Maybe<String>;
  dob?: Maybe<DateTimeInput>;
  State?: Maybe<String>;
  ctb?: Maybe<String>;
  education?: Maybe<String>;
  likes?: Maybe<Int>;
  remark?: Maybe<String>;
}

export interface LocationUpdateInput {
  town?: Maybe<String>;
  state?: Maybe<String>;
}

export interface LocationUpdateManyMutationInput {
  town?: Maybe<String>;
  state?: Maybe<String>;
}

export interface PostCreateInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  category?: Maybe<String>;
  body?: Maybe<String>;
  image?: Maybe<String>;
  desc?: Maybe<String>;
  author: UserCreateOneWithoutPostInput;
  comments?: Maybe<CommentCreateManyInput>;
}

export interface UserCreateOneWithoutPostInput {
  create?: Maybe<UserCreateWithoutPostInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutPostInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  image?: Maybe<String>;
  username?: Maybe<String>;
  password: String;
  firstName: String;
  lastName: String;
  phone?: Maybe<String>;
  email: String;
  about?: Maybe<String>;
  location?: Maybe<LocationCreateOneInput>;
  company?: Maybe<String>;
  tac?: Maybe<Boolean>;
  subscription?: Maybe<SubCreateOneInput>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordExpires?: Maybe<DateTimeInput>;
  isAdmin?: Maybe<Boolean>;
  emailConfirmationToken?: Maybe<String>;
  isActive?: Maybe<isActiveCreateOneInput>;
  joinedDate?: Maybe<DateTimeInput>;
}

export interface PostUpdateInput {
  title?: Maybe<String>;
  category?: Maybe<String>;
  body?: Maybe<String>;
  image?: Maybe<String>;
  desc?: Maybe<String>;
  author?: Maybe<UserUpdateOneRequiredWithoutPostInput>;
  comments?: Maybe<CommentUpdateManyInput>;
}

export interface UserUpdateOneRequiredWithoutPostInput {
  create?: Maybe<UserCreateWithoutPostInput>;
  update?: Maybe<UserUpdateWithoutPostDataInput>;
  upsert?: Maybe<UserUpsertWithoutPostInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutPostDataInput {
  name?: Maybe<String>;
  image?: Maybe<String>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  phone?: Maybe<String>;
  email?: Maybe<String>;
  about?: Maybe<String>;
  location?: Maybe<LocationUpdateOneInput>;
  company?: Maybe<String>;
  tac?: Maybe<Boolean>;
  subscription?: Maybe<SubUpdateOneInput>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordExpires?: Maybe<DateTimeInput>;
  isAdmin?: Maybe<Boolean>;
  emailConfirmationToken?: Maybe<String>;
  isActive?: Maybe<isActiveUpdateOneInput>;
  joinedDate?: Maybe<DateTimeInput>;
}

export interface UserUpsertWithoutPostInput {
  update: UserUpdateWithoutPostDataInput;
  create: UserCreateWithoutPostInput;
}

export interface PostUpdateManyMutationInput {
  title?: Maybe<String>;
  category?: Maybe<String>;
  body?: Maybe<String>;
  image?: Maybe<String>;
  desc?: Maybe<String>;
}

export interface QuestionUpdateInput {
  qns?: Maybe<String>;
  ans?: Maybe<String>;
}

export interface QuestionUpdateManyMutationInput {
  qns?: Maybe<String>;
  ans?: Maybe<String>;
}

export interface RatiosUpdateInput {
  heading?: Maybe<String>;
  contents?: Maybe<ContentsUpdateOneInput>;
}

export interface RatiosUpdateManyMutationInput {
  heading?: Maybe<String>;
}

export interface ReportCreateInput {
  id?: Maybe<ID_Input>;
  vols?: Maybe<VolCreateManyWithoutReportInput>;
  year?: Maybe<Int>;
}

export interface VolCreateManyWithoutReportInput {
  create?: Maybe<VolCreateWithoutReportInput[] | VolCreateWithoutReportInput>;
  connect?: Maybe<VolWhereUniqueInput[] | VolWhereUniqueInput>;
}

export interface VolCreateWithoutReportInput {
  id?: Maybe<ID_Input>;
  part_no: Int;
  cases?: Maybe<CasesCreateManyWithoutVolInput>;
  year: Int;
}

export interface CasesCreateManyWithoutVolInput {
  create?: Maybe<CasesCreateWithoutVolInput[] | CasesCreateWithoutVolInput>;
  connect?: Maybe<CasesWhereUniqueInput[] | CasesWhereUniqueInput>;
}

export interface CasesCreateWithoutVolInput {
  id?: Maybe<ID_Input>;
  title: String;
  likes?: Maybe<Int>;
  appellant?: Maybe<String>;
  respondent?: Maybe<String>;
  suit_no?: Maybe<String>;
  page_no?: Maybe<String>;
  State?: Maybe<String>;
  cat?: Maybe<String>;
  judges?: Maybe<JudgeCreateManyWithoutCasesInput>;
  counsel?: Maybe<CounselCreateOneInput>;
  appeal?: Maybe<String>;
  court?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  catchwords?: Maybe<String>;
  issues?: Maybe<IssuesCreateOneInput>;
  summary?: Maybe<String>;
  judgement?: Maybe<String>;
  cited?: Maybe<String>;
  books_cited?: Maybe<String>;
  determinations?: Maybe<String>;
}

export interface ReportUpdateInput {
  vols?: Maybe<VolUpdateManyWithoutReportInput>;
  year?: Maybe<Int>;
}

export interface VolUpdateManyWithoutReportInput {
  create?: Maybe<VolCreateWithoutReportInput[] | VolCreateWithoutReportInput>;
  delete?: Maybe<VolWhereUniqueInput[] | VolWhereUniqueInput>;
  connect?: Maybe<VolWhereUniqueInput[] | VolWhereUniqueInput>;
  set?: Maybe<VolWhereUniqueInput[] | VolWhereUniqueInput>;
  disconnect?: Maybe<VolWhereUniqueInput[] | VolWhereUniqueInput>;
  update?: Maybe<
    | VolUpdateWithWhereUniqueWithoutReportInput[]
    | VolUpdateWithWhereUniqueWithoutReportInput
  >;
  upsert?: Maybe<
    | VolUpsertWithWhereUniqueWithoutReportInput[]
    | VolUpsertWithWhereUniqueWithoutReportInput
  >;
  deleteMany?: Maybe<VolScalarWhereInput[] | VolScalarWhereInput>;
  updateMany?: Maybe<
    VolUpdateManyWithWhereNestedInput[] | VolUpdateManyWithWhereNestedInput
  >;
}

export interface VolUpdateWithWhereUniqueWithoutReportInput {
  where: VolWhereUniqueInput;
  data: VolUpdateWithoutReportDataInput;
}

export interface VolUpdateWithoutReportDataInput {
  part_no?: Maybe<Int>;
  cases?: Maybe<CasesUpdateManyWithoutVolInput>;
  year?: Maybe<Int>;
}

export interface CasesUpdateManyWithoutVolInput {
  create?: Maybe<CasesCreateWithoutVolInput[] | CasesCreateWithoutVolInput>;
  delete?: Maybe<CasesWhereUniqueInput[] | CasesWhereUniqueInput>;
  connect?: Maybe<CasesWhereUniqueInput[] | CasesWhereUniqueInput>;
  set?: Maybe<CasesWhereUniqueInput[] | CasesWhereUniqueInput>;
  disconnect?: Maybe<CasesWhereUniqueInput[] | CasesWhereUniqueInput>;
  update?: Maybe<
    | CasesUpdateWithWhereUniqueWithoutVolInput[]
    | CasesUpdateWithWhereUniqueWithoutVolInput
  >;
  upsert?: Maybe<
    | CasesUpsertWithWhereUniqueWithoutVolInput[]
    | CasesUpsertWithWhereUniqueWithoutVolInput
  >;
  deleteMany?: Maybe<CasesScalarWhereInput[] | CasesScalarWhereInput>;
  updateMany?: Maybe<
    CasesUpdateManyWithWhereNestedInput[] | CasesUpdateManyWithWhereNestedInput
  >;
}

export interface CasesUpdateWithWhereUniqueWithoutVolInput {
  where: CasesWhereUniqueInput;
  data: CasesUpdateWithoutVolDataInput;
}

export interface CasesUpdateWithoutVolDataInput {
  title?: Maybe<String>;
  likes?: Maybe<Int>;
  appellant?: Maybe<String>;
  respondent?: Maybe<String>;
  suit_no?: Maybe<String>;
  page_no?: Maybe<String>;
  State?: Maybe<String>;
  cat?: Maybe<String>;
  judges?: Maybe<JudgeUpdateManyWithoutCasesInput>;
  counsel?: Maybe<CounselUpdateOneInput>;
  appeal?: Maybe<String>;
  court?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  catchwords?: Maybe<String>;
  issues?: Maybe<IssuesUpdateOneInput>;
  summary?: Maybe<String>;
  judgement?: Maybe<String>;
  cited?: Maybe<String>;
  books_cited?: Maybe<String>;
  determinations?: Maybe<String>;
}

export interface CasesUpsertWithWhereUniqueWithoutVolInput {
  where: CasesWhereUniqueInput;
  update: CasesUpdateWithoutVolDataInput;
  create: CasesCreateWithoutVolInput;
}

export interface VolUpsertWithWhereUniqueWithoutReportInput {
  where: VolWhereUniqueInput;
  update: VolUpdateWithoutReportDataInput;
  create: VolCreateWithoutReportInput;
}

export interface VolScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  part_no?: Maybe<Int>;
  part_no_not?: Maybe<Int>;
  part_no_in?: Maybe<Int[] | Int>;
  part_no_not_in?: Maybe<Int[] | Int>;
  part_no_lt?: Maybe<Int>;
  part_no_lte?: Maybe<Int>;
  part_no_gt?: Maybe<Int>;
  part_no_gte?: Maybe<Int>;
  year?: Maybe<Int>;
  year_not?: Maybe<Int>;
  year_in?: Maybe<Int[] | Int>;
  year_not_in?: Maybe<Int[] | Int>;
  year_lt?: Maybe<Int>;
  year_lte?: Maybe<Int>;
  year_gt?: Maybe<Int>;
  year_gte?: Maybe<Int>;
  AND?: Maybe<VolScalarWhereInput[] | VolScalarWhereInput>;
  OR?: Maybe<VolScalarWhereInput[] | VolScalarWhereInput>;
  NOT?: Maybe<VolScalarWhereInput[] | VolScalarWhereInput>;
}

export interface VolUpdateManyWithWhereNestedInput {
  where: VolScalarWhereInput;
  data: VolUpdateManyDataInput;
}

export interface VolUpdateManyDataInput {
  part_no?: Maybe<Int>;
  year?: Maybe<Int>;
}

export interface ReportUpdateManyMutationInput {
  year?: Maybe<Int>;
}

export interface SubUpdateInput {
  plan?: Maybe<String>;
  days?: Maybe<Int>;
  startedIn?: Maybe<DateTimeInput>;
  expiresIn?: Maybe<DateTimeInput>;
  isActive?: Maybe<Boolean>;
}

export interface SubUpdateManyMutationInput {
  plan?: Maybe<String>;
  days?: Maybe<Int>;
  startedIn?: Maybe<DateTimeInput>;
  expiresIn?: Maybe<DateTimeInput>;
  isActive?: Maybe<Boolean>;
}

export interface UserUpdateInput {
  name?: Maybe<String>;
  image?: Maybe<String>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  phone?: Maybe<String>;
  email?: Maybe<String>;
  about?: Maybe<String>;
  location?: Maybe<LocationUpdateOneInput>;
  company?: Maybe<String>;
  tac?: Maybe<Boolean>;
  subscription?: Maybe<SubUpdateOneInput>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordExpires?: Maybe<DateTimeInput>;
  isAdmin?: Maybe<Boolean>;
  emailConfirmationToken?: Maybe<String>;
  isActive?: Maybe<isActiveUpdateOneInput>;
  joinedDate?: Maybe<DateTimeInput>;
  post?: Maybe<PostUpdateManyWithoutAuthorInput>;
}

export interface UserUpdateManyMutationInput {
  name?: Maybe<String>;
  image?: Maybe<String>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  phone?: Maybe<String>;
  email?: Maybe<String>;
  about?: Maybe<String>;
  company?: Maybe<String>;
  tac?: Maybe<Boolean>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordExpires?: Maybe<DateTimeInput>;
  isAdmin?: Maybe<Boolean>;
  emailConfirmationToken?: Maybe<String>;
  joinedDate?: Maybe<DateTimeInput>;
}

export interface VolCreateInput {
  id?: Maybe<ID_Input>;
  part_no: Int;
  cases?: Maybe<CasesCreateManyWithoutVolInput>;
  year: Int;
  report?: Maybe<ReportCreateOneWithoutVolsInput>;
}

export interface VolUpdateInput {
  part_no?: Maybe<Int>;
  cases?: Maybe<CasesUpdateManyWithoutVolInput>;
  year?: Maybe<Int>;
  report?: Maybe<ReportUpdateOneWithoutVolsInput>;
}

export interface VolUpdateManyMutationInput {
  part_no?: Maybe<Int>;
  year?: Maybe<Int>;
}

export interface isActiveUpdateInput {
  status?: Maybe<Boolean>;
  activedOn?: Maybe<DateTimeInput>;
}

export interface isActiveUpdateManyMutationInput {
  status?: Maybe<Boolean>;
  activedOn?: Maybe<DateTimeInput>;
}

export interface CasesSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CasesWhereInput>;
  AND?: Maybe<CasesSubscriptionWhereInput[] | CasesSubscriptionWhereInput>;
  OR?: Maybe<CasesSubscriptionWhereInput[] | CasesSubscriptionWhereInput>;
  NOT?: Maybe<CasesSubscriptionWhereInput[] | CasesSubscriptionWhereInput>;
}

export interface CategorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CategoryWhereInput>;
  AND?: Maybe<
    CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput
  >;
  OR?: Maybe<CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput>;
  NOT?: Maybe<
    CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput
  >;
}

export interface CommentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CommentWhereInput>;
  AND?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
  OR?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
  NOT?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
}

export interface ContentsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ContentsWhereInput>;
  AND?: Maybe<
    ContentsSubscriptionWhereInput[] | ContentsSubscriptionWhereInput
  >;
  OR?: Maybe<ContentsSubscriptionWhereInput[] | ContentsSubscriptionWhereInput>;
  NOT?: Maybe<
    ContentsSubscriptionWhereInput[] | ContentsSubscriptionWhereInput
  >;
}

export interface CounselSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CounselWhereInput>;
  AND?: Maybe<CounselSubscriptionWhereInput[] | CounselSubscriptionWhereInput>;
  OR?: Maybe<CounselSubscriptionWhereInput[] | CounselSubscriptionWhereInput>;
  NOT?: Maybe<CounselSubscriptionWhereInput[] | CounselSubscriptionWhereInput>;
}

export interface FaqSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FaqWhereInput>;
  AND?: Maybe<FaqSubscriptionWhereInput[] | FaqSubscriptionWhereInput>;
  OR?: Maybe<FaqSubscriptionWhereInput[] | FaqSubscriptionWhereInput>;
  NOT?: Maybe<FaqSubscriptionWhereInput[] | FaqSubscriptionWhereInput>;
}

export interface IssuesSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<IssuesWhereInput>;
  AND?: Maybe<IssuesSubscriptionWhereInput[] | IssuesSubscriptionWhereInput>;
  OR?: Maybe<IssuesSubscriptionWhereInput[] | IssuesSubscriptionWhereInput>;
  NOT?: Maybe<IssuesSubscriptionWhereInput[] | IssuesSubscriptionWhereInput>;
}

export interface JudgeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<JudgeWhereInput>;
  AND?: Maybe<JudgeSubscriptionWhereInput[] | JudgeSubscriptionWhereInput>;
  OR?: Maybe<JudgeSubscriptionWhereInput[] | JudgeSubscriptionWhereInput>;
  NOT?: Maybe<JudgeSubscriptionWhereInput[] | JudgeSubscriptionWhereInput>;
}

export interface LocationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LocationWhereInput>;
  AND?: Maybe<
    LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput
  >;
  OR?: Maybe<LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput>;
  NOT?: Maybe<
    LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput
  >;
}

export interface PostSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PostWhereInput>;
  AND?: Maybe<PostSubscriptionWhereInput[] | PostSubscriptionWhereInput>;
  OR?: Maybe<PostSubscriptionWhereInput[] | PostSubscriptionWhereInput>;
  NOT?: Maybe<PostSubscriptionWhereInput[] | PostSubscriptionWhereInput>;
}

export interface QuestionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<QuestionWhereInput>;
  AND?: Maybe<
    QuestionSubscriptionWhereInput[] | QuestionSubscriptionWhereInput
  >;
  OR?: Maybe<QuestionSubscriptionWhereInput[] | QuestionSubscriptionWhereInput>;
  NOT?: Maybe<
    QuestionSubscriptionWhereInput[] | QuestionSubscriptionWhereInput
  >;
}

export interface RatiosSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RatiosWhereInput>;
  AND?: Maybe<RatiosSubscriptionWhereInput[] | RatiosSubscriptionWhereInput>;
  OR?: Maybe<RatiosSubscriptionWhereInput[] | RatiosSubscriptionWhereInput>;
  NOT?: Maybe<RatiosSubscriptionWhereInput[] | RatiosSubscriptionWhereInput>;
}

export interface ReportSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ReportWhereInput>;
  AND?: Maybe<ReportSubscriptionWhereInput[] | ReportSubscriptionWhereInput>;
  OR?: Maybe<ReportSubscriptionWhereInput[] | ReportSubscriptionWhereInput>;
  NOT?: Maybe<ReportSubscriptionWhereInput[] | ReportSubscriptionWhereInput>;
}

export interface SubSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SubWhereInput>;
  AND?: Maybe<SubSubscriptionWhereInput[] | SubSubscriptionWhereInput>;
  OR?: Maybe<SubSubscriptionWhereInput[] | SubSubscriptionWhereInput>;
  NOT?: Maybe<SubSubscriptionWhereInput[] | SubSubscriptionWhereInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface VolSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<VolWhereInput>;
  AND?: Maybe<VolSubscriptionWhereInput[] | VolSubscriptionWhereInput>;
  OR?: Maybe<VolSubscriptionWhereInput[] | VolSubscriptionWhereInput>;
  NOT?: Maybe<VolSubscriptionWhereInput[] | VolSubscriptionWhereInput>;
}

export interface isActiveSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<isActiveWhereInput>;
  AND?: Maybe<
    isActiveSubscriptionWhereInput[] | isActiveSubscriptionWhereInput
  >;
  OR?: Maybe<isActiveSubscriptionWhereInput[] | isActiveSubscriptionWhereInput>;
  NOT?: Maybe<
    isActiveSubscriptionWhereInput[] | isActiveSubscriptionWhereInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Cases {
  id: ID_Output;
  title: String;
  likes?: Int;
  appellant?: String;
  respondent?: String;
  suit_no?: String;
  page_no?: String;
  State?: String;
  cat?: String;
  appeal?: String;
  court?: String;
  date?: DateTimeOutput;
  catchwords?: String;
  summary?: String;
  judgement?: String;
  cited?: String;
  books_cited?: String;
  determinations?: String;
}

export interface CasesPromise extends Promise<Cases>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  likes: () => Promise<Int>;
  appellant: () => Promise<String>;
  respondent: () => Promise<String>;
  suit_no: () => Promise<String>;
  page_no: () => Promise<String>;
  State: () => Promise<String>;
  cat: () => Promise<String>;
  judges: <T = FragmentableArray<Judge>>(args?: {
    where?: JudgeWhereInput;
    orderBy?: JudgeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  counsel: <T = CounselPromise>() => T;
  vol: <T = VolPromise>() => T;
  appeal: () => Promise<String>;
  court: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  catchwords: () => Promise<String>;
  issues: <T = IssuesPromise>() => T;
  summary: () => Promise<String>;
  judgement: () => Promise<String>;
  cited: () => Promise<String>;
  books_cited: () => Promise<String>;
  determinations: () => Promise<String>;
}

export interface CasesSubscription
  extends Promise<AsyncIterator<Cases>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  likes: () => Promise<AsyncIterator<Int>>;
  appellant: () => Promise<AsyncIterator<String>>;
  respondent: () => Promise<AsyncIterator<String>>;
  suit_no: () => Promise<AsyncIterator<String>>;
  page_no: () => Promise<AsyncIterator<String>>;
  State: () => Promise<AsyncIterator<String>>;
  cat: () => Promise<AsyncIterator<String>>;
  judges: <T = Promise<AsyncIterator<JudgeSubscription>>>(args?: {
    where?: JudgeWhereInput;
    orderBy?: JudgeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  counsel: <T = CounselSubscription>() => T;
  vol: <T = VolSubscription>() => T;
  appeal: () => Promise<AsyncIterator<String>>;
  court: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  catchwords: () => Promise<AsyncIterator<String>>;
  issues: <T = IssuesSubscription>() => T;
  summary: () => Promise<AsyncIterator<String>>;
  judgement: () => Promise<AsyncIterator<String>>;
  cited: () => Promise<AsyncIterator<String>>;
  books_cited: () => Promise<AsyncIterator<String>>;
  determinations: () => Promise<AsyncIterator<String>>;
}

export interface CasesNullablePromise
  extends Promise<Cases | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  likes: () => Promise<Int>;
  appellant: () => Promise<String>;
  respondent: () => Promise<String>;
  suit_no: () => Promise<String>;
  page_no: () => Promise<String>;
  State: () => Promise<String>;
  cat: () => Promise<String>;
  judges: <T = FragmentableArray<Judge>>(args?: {
    where?: JudgeWhereInput;
    orderBy?: JudgeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  counsel: <T = CounselPromise>() => T;
  vol: <T = VolPromise>() => T;
  appeal: () => Promise<String>;
  court: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  catchwords: () => Promise<String>;
  issues: <T = IssuesPromise>() => T;
  summary: () => Promise<String>;
  judgement: () => Promise<String>;
  cited: () => Promise<String>;
  books_cited: () => Promise<String>;
  determinations: () => Promise<String>;
}

export interface Judge {
  id: ID_Output;
  name: String;
  title: String;
  image: String;
  bio: String;
  dob?: DateTimeOutput;
  State: String;
  ctb: String;
  education: String;
  likes?: Int;
  remark: String;
}

export interface JudgePromise extends Promise<Judge>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  title: () => Promise<String>;
  image: () => Promise<String>;
  bio: () => Promise<String>;
  dob: () => Promise<DateTimeOutput>;
  State: () => Promise<String>;
  ctb: () => Promise<String>;
  education: () => Promise<String>;
  likes: () => Promise<Int>;
  remark: () => Promise<String>;
  cases: <T = FragmentableArray<Cases>>(args?: {
    where?: CasesWhereInput;
    orderBy?: CasesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface JudgeSubscription
  extends Promise<AsyncIterator<Judge>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  bio: () => Promise<AsyncIterator<String>>;
  dob: () => Promise<AsyncIterator<DateTimeOutput>>;
  State: () => Promise<AsyncIterator<String>>;
  ctb: () => Promise<AsyncIterator<String>>;
  education: () => Promise<AsyncIterator<String>>;
  likes: () => Promise<AsyncIterator<Int>>;
  remark: () => Promise<AsyncIterator<String>>;
  cases: <T = Promise<AsyncIterator<CasesSubscription>>>(args?: {
    where?: CasesWhereInput;
    orderBy?: CasesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface JudgeNullablePromise
  extends Promise<Judge | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  title: () => Promise<String>;
  image: () => Promise<String>;
  bio: () => Promise<String>;
  dob: () => Promise<DateTimeOutput>;
  State: () => Promise<String>;
  ctb: () => Promise<String>;
  education: () => Promise<String>;
  likes: () => Promise<Int>;
  remark: () => Promise<String>;
  cases: <T = FragmentableArray<Cases>>(args?: {
    where?: CasesWhereInput;
    orderBy?: CasesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Counsel {
  id: ID_Output;
  appellant?: String;
  respondent?: String;
}

export interface CounselPromise extends Promise<Counsel>, Fragmentable {
  id: () => Promise<ID_Output>;
  appellant: () => Promise<String>;
  respondent: () => Promise<String>;
}

export interface CounselSubscription
  extends Promise<AsyncIterator<Counsel>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  appellant: () => Promise<AsyncIterator<String>>;
  respondent: () => Promise<AsyncIterator<String>>;
}

export interface CounselNullablePromise
  extends Promise<Counsel | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  appellant: () => Promise<String>;
  respondent: () => Promise<String>;
}

export interface Vol {
  id: ID_Output;
  part_no: Int;
  year: Int;
}

export interface VolPromise extends Promise<Vol>, Fragmentable {
  id: () => Promise<ID_Output>;
  part_no: () => Promise<Int>;
  cases: <T = FragmentableArray<Cases>>(args?: {
    where?: CasesWhereInput;
    orderBy?: CasesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  year: () => Promise<Int>;
  report: <T = ReportPromise>() => T;
}

export interface VolSubscription
  extends Promise<AsyncIterator<Vol>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  part_no: () => Promise<AsyncIterator<Int>>;
  cases: <T = Promise<AsyncIterator<CasesSubscription>>>(args?: {
    where?: CasesWhereInput;
    orderBy?: CasesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  year: () => Promise<AsyncIterator<Int>>;
  report: <T = ReportSubscription>() => T;
}

export interface VolNullablePromise extends Promise<Vol | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  part_no: () => Promise<Int>;
  cases: <T = FragmentableArray<Cases>>(args?: {
    where?: CasesWhereInput;
    orderBy?: CasesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  year: () => Promise<Int>;
  report: <T = ReportPromise>() => T;
}

export interface Report {
  id: ID_Output;
  year?: Int;
}

export interface ReportPromise extends Promise<Report>, Fragmentable {
  id: () => Promise<ID_Output>;
  vols: <T = FragmentableArray<Vol>>(args?: {
    where?: VolWhereInput;
    orderBy?: VolOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  year: () => Promise<Int>;
}

export interface ReportSubscription
  extends Promise<AsyncIterator<Report>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  vols: <T = Promise<AsyncIterator<VolSubscription>>>(args?: {
    where?: VolWhereInput;
    orderBy?: VolOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  year: () => Promise<AsyncIterator<Int>>;
}

export interface ReportNullablePromise
  extends Promise<Report | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  vols: <T = FragmentableArray<Vol>>(args?: {
    where?: VolWhereInput;
    orderBy?: VolOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  year: () => Promise<Int>;
}

export interface Issues {
  id: ID_Output;
  status?: String;
}

export interface IssuesPromise extends Promise<Issues>, Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<String>;
  ratios: <T = FragmentableArray<Ratios>>(args?: {
    where?: RatiosWhereInput;
    orderBy?: RatiosOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface IssuesSubscription
  extends Promise<AsyncIterator<Issues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<String>>;
  ratios: <T = Promise<AsyncIterator<RatiosSubscription>>>(args?: {
    where?: RatiosWhereInput;
    orderBy?: RatiosOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface IssuesNullablePromise
  extends Promise<Issues | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<String>;
  ratios: <T = FragmentableArray<Ratios>>(args?: {
    where?: RatiosWhereInput;
    orderBy?: RatiosOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Ratios {
  id: ID_Output;
  heading?: String;
}

export interface RatiosPromise extends Promise<Ratios>, Fragmentable {
  id: () => Promise<ID_Output>;
  heading: () => Promise<String>;
  contents: <T = ContentsPromise>() => T;
}

export interface RatiosSubscription
  extends Promise<AsyncIterator<Ratios>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  heading: () => Promise<AsyncIterator<String>>;
  contents: <T = ContentsSubscription>() => T;
}

export interface RatiosNullablePromise
  extends Promise<Ratios | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  heading: () => Promise<String>;
  contents: <T = ContentsPromise>() => T;
}

export interface Contents {
  id: ID_Output;
  ref?: String;
  body?: String;
}

export interface ContentsPromise extends Promise<Contents>, Fragmentable {
  id: () => Promise<ID_Output>;
  quoted: <T = JudgePromise>() => T;
  ref: () => Promise<String>;
  body: () => Promise<String>;
}

export interface ContentsSubscription
  extends Promise<AsyncIterator<Contents>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  quoted: <T = JudgeSubscription>() => T;
  ref: () => Promise<AsyncIterator<String>>;
  body: () => Promise<AsyncIterator<String>>;
}

export interface ContentsNullablePromise
  extends Promise<Contents | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  quoted: <T = JudgePromise>() => T;
  ref: () => Promise<String>;
  body: () => Promise<String>;
}

export interface CasesConnection {
  pageInfo: PageInfo;
  edges: CasesEdge[];
}

export interface CasesConnectionPromise
  extends Promise<CasesConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CasesEdge>>() => T;
  aggregate: <T = AggregateCasesPromise>() => T;
}

export interface CasesConnectionSubscription
  extends Promise<AsyncIterator<CasesConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CasesEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCasesSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface CasesEdge {
  node: Cases;
  cursor: String;
}

export interface CasesEdgePromise extends Promise<CasesEdge>, Fragmentable {
  node: <T = CasesPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CasesEdgeSubscription
  extends Promise<AsyncIterator<CasesEdge>>,
    Fragmentable {
  node: <T = CasesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCases {
  count: Int;
}

export interface AggregateCasesPromise
  extends Promise<AggregateCases>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCasesSubscription
  extends Promise<AsyncIterator<AggregateCases>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Category {
  id: ID_Output;
  category: String;
  desc: String;
  createdAt?: DateTimeOutput;
}

export interface CategoryPromise extends Promise<Category>, Fragmentable {
  id: () => Promise<ID_Output>;
  category: () => Promise<String>;
  desc: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  faq: <T = FragmentableArray<Faq>>(args?: {
    where?: FaqWhereInput;
    orderBy?: FaqOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CategorySubscription
  extends Promise<AsyncIterator<Category>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  category: () => Promise<AsyncIterator<String>>;
  desc: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  faq: <T = Promise<AsyncIterator<FaqSubscription>>>(args?: {
    where?: FaqWhereInput;
    orderBy?: FaqOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CategoryNullablePromise
  extends Promise<Category | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  category: () => Promise<String>;
  desc: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  faq: <T = FragmentableArray<Faq>>(args?: {
    where?: FaqWhereInput;
    orderBy?: FaqOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Faq {
  id: ID_Output;
  title: String;
  createdAt?: DateTimeOutput;
  desc: String;
}

export interface FaqPromise extends Promise<Faq>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  category: <T = CategoryPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  desc: () => Promise<String>;
  questions: <T = FragmentableArray<Question>>(args?: {
    where?: QuestionWhereInput;
    orderBy?: QuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface FaqSubscription
  extends Promise<AsyncIterator<Faq>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  category: <T = CategorySubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  desc: () => Promise<AsyncIterator<String>>;
  questions: <T = Promise<AsyncIterator<QuestionSubscription>>>(args?: {
    where?: QuestionWhereInput;
    orderBy?: QuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface FaqNullablePromise extends Promise<Faq | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  category: <T = CategoryPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  desc: () => Promise<String>;
  questions: <T = FragmentableArray<Question>>(args?: {
    where?: QuestionWhereInput;
    orderBy?: QuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Question {
  id: ID_Output;
  qns: String;
  ans: String;
}

export interface QuestionPromise extends Promise<Question>, Fragmentable {
  id: () => Promise<ID_Output>;
  qns: () => Promise<String>;
  ans: () => Promise<String>;
}

export interface QuestionSubscription
  extends Promise<AsyncIterator<Question>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  qns: () => Promise<AsyncIterator<String>>;
  ans: () => Promise<AsyncIterator<String>>;
}

export interface QuestionNullablePromise
  extends Promise<Question | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  qns: () => Promise<String>;
  ans: () => Promise<String>;
}

export interface CategoryConnection {
  pageInfo: PageInfo;
  edges: CategoryEdge[];
}

export interface CategoryConnectionPromise
  extends Promise<CategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CategoryEdge>>() => T;
  aggregate: <T = AggregateCategoryPromise>() => T;
}

export interface CategoryConnectionSubscription
  extends Promise<AsyncIterator<CategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCategorySubscription>() => T;
}

export interface CategoryEdge {
  node: Category;
  cursor: String;
}

export interface CategoryEdgePromise
  extends Promise<CategoryEdge>,
    Fragmentable {
  node: <T = CategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CategoryEdgeSubscription
  extends Promise<AsyncIterator<CategoryEdge>>,
    Fragmentable {
  node: <T = CategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCategory {
  count: Int;
}

export interface AggregateCategoryPromise
  extends Promise<AggregateCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCategorySubscription
  extends Promise<AsyncIterator<AggregateCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Comment {
  id: ID_Output;
  body?: String;
  createdAt?: DateTimeOutput;
}

export interface CommentPromise extends Promise<Comment>, Fragmentable {
  id: () => Promise<ID_Output>;
  body: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  author: <T = UserPromise>() => T;
}

export interface CommentSubscription
  extends Promise<AsyncIterator<Comment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  body: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  author: <T = UserSubscription>() => T;
}

export interface CommentNullablePromise
  extends Promise<Comment | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  body: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  author: <T = UserPromise>() => T;
}

export interface User {
  id: ID_Output;
  name?: String;
  image?: String;
  username?: String;
  password: String;
  firstName: String;
  lastName: String;
  phone?: String;
  email: String;
  about?: String;
  company?: String;
  tac?: Boolean;
  resetPasswordToken?: String;
  resetPasswordExpires?: DateTimeOutput;
  isAdmin?: Boolean;
  emailConfirmationToken?: String;
  joinedDate?: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  image: () => Promise<String>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  phone: () => Promise<String>;
  email: () => Promise<String>;
  about: () => Promise<String>;
  location: <T = LocationPromise>() => T;
  company: () => Promise<String>;
  tac: () => Promise<Boolean>;
  subscription: <T = SubPromise>() => T;
  resetPasswordToken: () => Promise<String>;
  resetPasswordExpires: () => Promise<DateTimeOutput>;
  isAdmin: () => Promise<Boolean>;
  emailConfirmationToken: () => Promise<String>;
  isActive: <T = isActivePromise>() => T;
  joinedDate: () => Promise<DateTimeOutput>;
  post: <T = FragmentableArray<Post>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  about: () => Promise<AsyncIterator<String>>;
  location: <T = LocationSubscription>() => T;
  company: () => Promise<AsyncIterator<String>>;
  tac: () => Promise<AsyncIterator<Boolean>>;
  subscription: <T = SubSubscription>() => T;
  resetPasswordToken: () => Promise<AsyncIterator<String>>;
  resetPasswordExpires: () => Promise<AsyncIterator<DateTimeOutput>>;
  isAdmin: () => Promise<AsyncIterator<Boolean>>;
  emailConfirmationToken: () => Promise<AsyncIterator<String>>;
  isActive: <T = isActiveSubscription>() => T;
  joinedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  post: <T = Promise<AsyncIterator<PostSubscription>>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  image: () => Promise<String>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  phone: () => Promise<String>;
  email: () => Promise<String>;
  about: () => Promise<String>;
  location: <T = LocationPromise>() => T;
  company: () => Promise<String>;
  tac: () => Promise<Boolean>;
  subscription: <T = SubPromise>() => T;
  resetPasswordToken: () => Promise<String>;
  resetPasswordExpires: () => Promise<DateTimeOutput>;
  isAdmin: () => Promise<Boolean>;
  emailConfirmationToken: () => Promise<String>;
  isActive: <T = isActivePromise>() => T;
  joinedDate: () => Promise<DateTimeOutput>;
  post: <T = FragmentableArray<Post>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Location {
  id: ID_Output;
  town?: String;
  state?: String;
}

export interface LocationPromise extends Promise<Location>, Fragmentable {
  id: () => Promise<ID_Output>;
  town: () => Promise<String>;
  state: () => Promise<String>;
}

export interface LocationSubscription
  extends Promise<AsyncIterator<Location>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  town: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
}

export interface LocationNullablePromise
  extends Promise<Location | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  town: () => Promise<String>;
  state: () => Promise<String>;
}

export interface Sub {
  id: ID_Output;
  plan?: String;
  days?: Int;
  startedIn?: DateTimeOutput;
  expiresIn?: DateTimeOutput;
  isActive?: Boolean;
}

export interface SubPromise extends Promise<Sub>, Fragmentable {
  id: () => Promise<ID_Output>;
  plan: () => Promise<String>;
  days: () => Promise<Int>;
  startedIn: () => Promise<DateTimeOutput>;
  expiresIn: () => Promise<DateTimeOutput>;
  isActive: () => Promise<Boolean>;
}

export interface SubSubscription
  extends Promise<AsyncIterator<Sub>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  plan: () => Promise<AsyncIterator<String>>;
  days: () => Promise<AsyncIterator<Int>>;
  startedIn: () => Promise<AsyncIterator<DateTimeOutput>>;
  expiresIn: () => Promise<AsyncIterator<DateTimeOutput>>;
  isActive: () => Promise<AsyncIterator<Boolean>>;
}

export interface SubNullablePromise extends Promise<Sub | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  plan: () => Promise<String>;
  days: () => Promise<Int>;
  startedIn: () => Promise<DateTimeOutput>;
  expiresIn: () => Promise<DateTimeOutput>;
  isActive: () => Promise<Boolean>;
}

export interface isActive {
  id: ID_Output;
  status?: Boolean;
  activedOn?: DateTimeOutput;
}

export interface isActivePromise extends Promise<isActive>, Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<Boolean>;
  activedOn: () => Promise<DateTimeOutput>;
}

export interface isActiveSubscription
  extends Promise<AsyncIterator<isActive>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<Boolean>>;
  activedOn: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface isActiveNullablePromise
  extends Promise<isActive | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<Boolean>;
  activedOn: () => Promise<DateTimeOutput>;
}

export interface Post {
  id: ID_Output;
  title?: String;
  category?: String;
  body?: String;
  image?: String;
  desc?: String;
  createdAt?: DateTimeOutput;
}

export interface PostPromise extends Promise<Post>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  category: () => Promise<String>;
  body: () => Promise<String>;
  image: () => Promise<String>;
  desc: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  author: <T = UserPromise>() => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PostSubscription
  extends Promise<AsyncIterator<Post>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  category: () => Promise<AsyncIterator<String>>;
  body: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  desc: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  author: <T = UserSubscription>() => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PostNullablePromise
  extends Promise<Post | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  category: () => Promise<String>;
  body: () => Promise<String>;
  image: () => Promise<String>;
  desc: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  author: <T = UserPromise>() => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CommentConnection {
  pageInfo: PageInfo;
  edges: CommentEdge[];
}

export interface CommentConnectionPromise
  extends Promise<CommentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommentEdge>>() => T;
  aggregate: <T = AggregateCommentPromise>() => T;
}

export interface CommentConnectionSubscription
  extends Promise<AsyncIterator<CommentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommentSubscription>() => T;
}

export interface CommentEdge {
  node: Comment;
  cursor: String;
}

export interface CommentEdgePromise extends Promise<CommentEdge>, Fragmentable {
  node: <T = CommentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommentEdgeSubscription
  extends Promise<AsyncIterator<CommentEdge>>,
    Fragmentable {
  node: <T = CommentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateComment {
  count: Int;
}

export interface AggregateCommentPromise
  extends Promise<AggregateComment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommentSubscription
  extends Promise<AsyncIterator<AggregateComment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ContentsConnection {
  pageInfo: PageInfo;
  edges: ContentsEdge[];
}

export interface ContentsConnectionPromise
  extends Promise<ContentsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ContentsEdge>>() => T;
  aggregate: <T = AggregateContentsPromise>() => T;
}

export interface ContentsConnectionSubscription
  extends Promise<AsyncIterator<ContentsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ContentsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateContentsSubscription>() => T;
}

export interface ContentsEdge {
  node: Contents;
  cursor: String;
}

export interface ContentsEdgePromise
  extends Promise<ContentsEdge>,
    Fragmentable {
  node: <T = ContentsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ContentsEdgeSubscription
  extends Promise<AsyncIterator<ContentsEdge>>,
    Fragmentable {
  node: <T = ContentsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateContents {
  count: Int;
}

export interface AggregateContentsPromise
  extends Promise<AggregateContents>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateContentsSubscription
  extends Promise<AsyncIterator<AggregateContents>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CounselConnection {
  pageInfo: PageInfo;
  edges: CounselEdge[];
}

export interface CounselConnectionPromise
  extends Promise<CounselConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CounselEdge>>() => T;
  aggregate: <T = AggregateCounselPromise>() => T;
}

export interface CounselConnectionSubscription
  extends Promise<AsyncIterator<CounselConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CounselEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCounselSubscription>() => T;
}

export interface CounselEdge {
  node: Counsel;
  cursor: String;
}

export interface CounselEdgePromise extends Promise<CounselEdge>, Fragmentable {
  node: <T = CounselPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CounselEdgeSubscription
  extends Promise<AsyncIterator<CounselEdge>>,
    Fragmentable {
  node: <T = CounselSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCounsel {
  count: Int;
}

export interface AggregateCounselPromise
  extends Promise<AggregateCounsel>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCounselSubscription
  extends Promise<AsyncIterator<AggregateCounsel>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FaqConnection {
  pageInfo: PageInfo;
  edges: FaqEdge[];
}

export interface FaqConnectionPromise
  extends Promise<FaqConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FaqEdge>>() => T;
  aggregate: <T = AggregateFaqPromise>() => T;
}

export interface FaqConnectionSubscription
  extends Promise<AsyncIterator<FaqConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FaqEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFaqSubscription>() => T;
}

export interface FaqEdge {
  node: Faq;
  cursor: String;
}

export interface FaqEdgePromise extends Promise<FaqEdge>, Fragmentable {
  node: <T = FaqPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FaqEdgeSubscription
  extends Promise<AsyncIterator<FaqEdge>>,
    Fragmentable {
  node: <T = FaqSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFaq {
  count: Int;
}

export interface AggregateFaqPromise
  extends Promise<AggregateFaq>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFaqSubscription
  extends Promise<AsyncIterator<AggregateFaq>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface IssuesConnection {
  pageInfo: PageInfo;
  edges: IssuesEdge[];
}

export interface IssuesConnectionPromise
  extends Promise<IssuesConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<IssuesEdge>>() => T;
  aggregate: <T = AggregateIssuesPromise>() => T;
}

export interface IssuesConnectionSubscription
  extends Promise<AsyncIterator<IssuesConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<IssuesEdgeSubscription>>>() => T;
  aggregate: <T = AggregateIssuesSubscription>() => T;
}

export interface IssuesEdge {
  node: Issues;
  cursor: String;
}

export interface IssuesEdgePromise extends Promise<IssuesEdge>, Fragmentable {
  node: <T = IssuesPromise>() => T;
  cursor: () => Promise<String>;
}

export interface IssuesEdgeSubscription
  extends Promise<AsyncIterator<IssuesEdge>>,
    Fragmentable {
  node: <T = IssuesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateIssues {
  count: Int;
}

export interface AggregateIssuesPromise
  extends Promise<AggregateIssues>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateIssuesSubscription
  extends Promise<AsyncIterator<AggregateIssues>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface JudgeConnection {
  pageInfo: PageInfo;
  edges: JudgeEdge[];
}

export interface JudgeConnectionPromise
  extends Promise<JudgeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<JudgeEdge>>() => T;
  aggregate: <T = AggregateJudgePromise>() => T;
}

export interface JudgeConnectionSubscription
  extends Promise<AsyncIterator<JudgeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<JudgeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateJudgeSubscription>() => T;
}

export interface JudgeEdge {
  node: Judge;
  cursor: String;
}

export interface JudgeEdgePromise extends Promise<JudgeEdge>, Fragmentable {
  node: <T = JudgePromise>() => T;
  cursor: () => Promise<String>;
}

export interface JudgeEdgeSubscription
  extends Promise<AsyncIterator<JudgeEdge>>,
    Fragmentable {
  node: <T = JudgeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateJudge {
  count: Int;
}

export interface AggregateJudgePromise
  extends Promise<AggregateJudge>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateJudgeSubscription
  extends Promise<AsyncIterator<AggregateJudge>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LocationConnection {
  pageInfo: PageInfo;
  edges: LocationEdge[];
}

export interface LocationConnectionPromise
  extends Promise<LocationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LocationEdge>>() => T;
  aggregate: <T = AggregateLocationPromise>() => T;
}

export interface LocationConnectionSubscription
  extends Promise<AsyncIterator<LocationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LocationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLocationSubscription>() => T;
}

export interface LocationEdge {
  node: Location;
  cursor: String;
}

export interface LocationEdgePromise
  extends Promise<LocationEdge>,
    Fragmentable {
  node: <T = LocationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LocationEdgeSubscription
  extends Promise<AsyncIterator<LocationEdge>>,
    Fragmentable {
  node: <T = LocationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLocation {
  count: Int;
}

export interface AggregateLocationPromise
  extends Promise<AggregateLocation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLocationSubscription
  extends Promise<AsyncIterator<AggregateLocation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PostConnection {
  pageInfo: PageInfo;
  edges: PostEdge[];
}

export interface PostConnectionPromise
  extends Promise<PostConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PostEdge>>() => T;
  aggregate: <T = AggregatePostPromise>() => T;
}

export interface PostConnectionSubscription
  extends Promise<AsyncIterator<PostConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PostEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePostSubscription>() => T;
}

export interface PostEdge {
  node: Post;
  cursor: String;
}

export interface PostEdgePromise extends Promise<PostEdge>, Fragmentable {
  node: <T = PostPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PostEdgeSubscription
  extends Promise<AsyncIterator<PostEdge>>,
    Fragmentable {
  node: <T = PostSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePost {
  count: Int;
}

export interface AggregatePostPromise
  extends Promise<AggregatePost>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePostSubscription
  extends Promise<AsyncIterator<AggregatePost>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface QuestionConnection {
  pageInfo: PageInfo;
  edges: QuestionEdge[];
}

export interface QuestionConnectionPromise
  extends Promise<QuestionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QuestionEdge>>() => T;
  aggregate: <T = AggregateQuestionPromise>() => T;
}

export interface QuestionConnectionSubscription
  extends Promise<AsyncIterator<QuestionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<QuestionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateQuestionSubscription>() => T;
}

export interface QuestionEdge {
  node: Question;
  cursor: String;
}

export interface QuestionEdgePromise
  extends Promise<QuestionEdge>,
    Fragmentable {
  node: <T = QuestionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface QuestionEdgeSubscription
  extends Promise<AsyncIterator<QuestionEdge>>,
    Fragmentable {
  node: <T = QuestionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateQuestion {
  count: Int;
}

export interface AggregateQuestionPromise
  extends Promise<AggregateQuestion>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQuestionSubscription
  extends Promise<AsyncIterator<AggregateQuestion>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RatiosConnection {
  pageInfo: PageInfo;
  edges: RatiosEdge[];
}

export interface RatiosConnectionPromise
  extends Promise<RatiosConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RatiosEdge>>() => T;
  aggregate: <T = AggregateRatiosPromise>() => T;
}

export interface RatiosConnectionSubscription
  extends Promise<AsyncIterator<RatiosConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RatiosEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRatiosSubscription>() => T;
}

export interface RatiosEdge {
  node: Ratios;
  cursor: String;
}

export interface RatiosEdgePromise extends Promise<RatiosEdge>, Fragmentable {
  node: <T = RatiosPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RatiosEdgeSubscription
  extends Promise<AsyncIterator<RatiosEdge>>,
    Fragmentable {
  node: <T = RatiosSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRatios {
  count: Int;
}

export interface AggregateRatiosPromise
  extends Promise<AggregateRatios>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRatiosSubscription
  extends Promise<AsyncIterator<AggregateRatios>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ReportConnection {
  pageInfo: PageInfo;
  edges: ReportEdge[];
}

export interface ReportConnectionPromise
  extends Promise<ReportConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ReportEdge>>() => T;
  aggregate: <T = AggregateReportPromise>() => T;
}

export interface ReportConnectionSubscription
  extends Promise<AsyncIterator<ReportConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ReportEdgeSubscription>>>() => T;
  aggregate: <T = AggregateReportSubscription>() => T;
}

export interface ReportEdge {
  node: Report;
  cursor: String;
}

export interface ReportEdgePromise extends Promise<ReportEdge>, Fragmentable {
  node: <T = ReportPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ReportEdgeSubscription
  extends Promise<AsyncIterator<ReportEdge>>,
    Fragmentable {
  node: <T = ReportSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateReport {
  count: Int;
}

export interface AggregateReportPromise
  extends Promise<AggregateReport>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateReportSubscription
  extends Promise<AsyncIterator<AggregateReport>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SubConnection {
  pageInfo: PageInfo;
  edges: SubEdge[];
}

export interface SubConnectionPromise
  extends Promise<SubConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SubEdge>>() => T;
  aggregate: <T = AggregateSubPromise>() => T;
}

export interface SubConnectionSubscription
  extends Promise<AsyncIterator<SubConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SubEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSubSubscription>() => T;
}

export interface SubEdge {
  node: Sub;
  cursor: String;
}

export interface SubEdgePromise extends Promise<SubEdge>, Fragmentable {
  node: <T = SubPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SubEdgeSubscription
  extends Promise<AsyncIterator<SubEdge>>,
    Fragmentable {
  node: <T = SubSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSub {
  count: Int;
}

export interface AggregateSubPromise
  extends Promise<AggregateSub>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSubSubscription
  extends Promise<AsyncIterator<AggregateSub>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VolConnection {
  pageInfo: PageInfo;
  edges: VolEdge[];
}

export interface VolConnectionPromise
  extends Promise<VolConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VolEdge>>() => T;
  aggregate: <T = AggregateVolPromise>() => T;
}

export interface VolConnectionSubscription
  extends Promise<AsyncIterator<VolConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VolEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVolSubscription>() => T;
}

export interface VolEdge {
  node: Vol;
  cursor: String;
}

export interface VolEdgePromise extends Promise<VolEdge>, Fragmentable {
  node: <T = VolPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VolEdgeSubscription
  extends Promise<AsyncIterator<VolEdge>>,
    Fragmentable {
  node: <T = VolSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateVol {
  count: Int;
}

export interface AggregateVolPromise
  extends Promise<AggregateVol>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVolSubscription
  extends Promise<AsyncIterator<AggregateVol>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface isActiveConnection {
  pageInfo: PageInfo;
  edges: isActiveEdge[];
}

export interface isActiveConnectionPromise
  extends Promise<isActiveConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<isActiveEdge>>() => T;
  aggregate: <T = AggregateisActivePromise>() => T;
}

export interface isActiveConnectionSubscription
  extends Promise<AsyncIterator<isActiveConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<isActiveEdgeSubscription>>>() => T;
  aggregate: <T = AggregateisActiveSubscription>() => T;
}

export interface isActiveEdge {
  node: isActive;
  cursor: String;
}

export interface isActiveEdgePromise
  extends Promise<isActiveEdge>,
    Fragmentable {
  node: <T = isActivePromise>() => T;
  cursor: () => Promise<String>;
}

export interface isActiveEdgeSubscription
  extends Promise<AsyncIterator<isActiveEdge>>,
    Fragmentable {
  node: <T = isActiveSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateisActive {
  count: Int;
}

export interface AggregateisActivePromise
  extends Promise<AggregateisActive>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateisActiveSubscription
  extends Promise<AsyncIterator<AggregateisActive>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface CasesSubscriptionPayload {
  mutation: MutationType;
  node: Cases;
  updatedFields: String[];
  previousValues: CasesPreviousValues;
}

export interface CasesSubscriptionPayloadPromise
  extends Promise<CasesSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CasesPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CasesPreviousValuesPromise>() => T;
}

export interface CasesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CasesSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CasesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CasesPreviousValuesSubscription>() => T;
}

export interface CasesPreviousValues {
  id: ID_Output;
  title: String;
  likes?: Int;
  appellant?: String;
  respondent?: String;
  suit_no?: String;
  page_no?: String;
  State?: String;
  cat?: String;
  appeal?: String;
  court?: String;
  date?: DateTimeOutput;
  catchwords?: String;
  summary?: String;
  judgement?: String;
  cited?: String;
  books_cited?: String;
  determinations?: String;
}

export interface CasesPreviousValuesPromise
  extends Promise<CasesPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  likes: () => Promise<Int>;
  appellant: () => Promise<String>;
  respondent: () => Promise<String>;
  suit_no: () => Promise<String>;
  page_no: () => Promise<String>;
  State: () => Promise<String>;
  cat: () => Promise<String>;
  appeal: () => Promise<String>;
  court: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  catchwords: () => Promise<String>;
  summary: () => Promise<String>;
  judgement: () => Promise<String>;
  cited: () => Promise<String>;
  books_cited: () => Promise<String>;
  determinations: () => Promise<String>;
}

export interface CasesPreviousValuesSubscription
  extends Promise<AsyncIterator<CasesPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  likes: () => Promise<AsyncIterator<Int>>;
  appellant: () => Promise<AsyncIterator<String>>;
  respondent: () => Promise<AsyncIterator<String>>;
  suit_no: () => Promise<AsyncIterator<String>>;
  page_no: () => Promise<AsyncIterator<String>>;
  State: () => Promise<AsyncIterator<String>>;
  cat: () => Promise<AsyncIterator<String>>;
  appeal: () => Promise<AsyncIterator<String>>;
  court: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  catchwords: () => Promise<AsyncIterator<String>>;
  summary: () => Promise<AsyncIterator<String>>;
  judgement: () => Promise<AsyncIterator<String>>;
  cited: () => Promise<AsyncIterator<String>>;
  books_cited: () => Promise<AsyncIterator<String>>;
  determinations: () => Promise<AsyncIterator<String>>;
}

export interface CategorySubscriptionPayload {
  mutation: MutationType;
  node: Category;
  updatedFields: String[];
  previousValues: CategoryPreviousValues;
}

export interface CategorySubscriptionPayloadPromise
  extends Promise<CategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CategoryPreviousValuesPromise>() => T;
}

export interface CategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CategoryPreviousValuesSubscription>() => T;
}

export interface CategoryPreviousValues {
  id: ID_Output;
  category: String;
  desc: String;
  createdAt?: DateTimeOutput;
}

export interface CategoryPreviousValuesPromise
  extends Promise<CategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  category: () => Promise<String>;
  desc: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<CategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  category: () => Promise<AsyncIterator<String>>;
  desc: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CommentSubscriptionPayload {
  mutation: MutationType;
  node: Comment;
  updatedFields: String[];
  previousValues: CommentPreviousValues;
}

export interface CommentSubscriptionPayloadPromise
  extends Promise<CommentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommentPreviousValuesPromise>() => T;
}

export interface CommentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommentPreviousValuesSubscription>() => T;
}

export interface CommentPreviousValues {
  id: ID_Output;
  body?: String;
  createdAt?: DateTimeOutput;
}

export interface CommentPreviousValuesPromise
  extends Promise<CommentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  body: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CommentPreviousValuesSubscription
  extends Promise<AsyncIterator<CommentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  body: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ContentsSubscriptionPayload {
  mutation: MutationType;
  node: Contents;
  updatedFields: String[];
  previousValues: ContentsPreviousValues;
}

export interface ContentsSubscriptionPayloadPromise
  extends Promise<ContentsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ContentsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ContentsPreviousValuesPromise>() => T;
}

export interface ContentsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ContentsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ContentsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ContentsPreviousValuesSubscription>() => T;
}

export interface ContentsPreviousValues {
  id: ID_Output;
  ref?: String;
  body?: String;
}

export interface ContentsPreviousValuesPromise
  extends Promise<ContentsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  ref: () => Promise<String>;
  body: () => Promise<String>;
}

export interface ContentsPreviousValuesSubscription
  extends Promise<AsyncIterator<ContentsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  ref: () => Promise<AsyncIterator<String>>;
  body: () => Promise<AsyncIterator<String>>;
}

export interface CounselSubscriptionPayload {
  mutation: MutationType;
  node: Counsel;
  updatedFields: String[];
  previousValues: CounselPreviousValues;
}

export interface CounselSubscriptionPayloadPromise
  extends Promise<CounselSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CounselPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CounselPreviousValuesPromise>() => T;
}

export interface CounselSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CounselSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CounselSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CounselPreviousValuesSubscription>() => T;
}

export interface CounselPreviousValues {
  id: ID_Output;
  appellant?: String;
  respondent?: String;
}

export interface CounselPreviousValuesPromise
  extends Promise<CounselPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  appellant: () => Promise<String>;
  respondent: () => Promise<String>;
}

export interface CounselPreviousValuesSubscription
  extends Promise<AsyncIterator<CounselPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  appellant: () => Promise<AsyncIterator<String>>;
  respondent: () => Promise<AsyncIterator<String>>;
}

export interface FaqSubscriptionPayload {
  mutation: MutationType;
  node: Faq;
  updatedFields: String[];
  previousValues: FaqPreviousValues;
}

export interface FaqSubscriptionPayloadPromise
  extends Promise<FaqSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FaqPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FaqPreviousValuesPromise>() => T;
}

export interface FaqSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FaqSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FaqSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FaqPreviousValuesSubscription>() => T;
}

export interface FaqPreviousValues {
  id: ID_Output;
  title: String;
  createdAt?: DateTimeOutput;
  desc: String;
}

export interface FaqPreviousValuesPromise
  extends Promise<FaqPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  desc: () => Promise<String>;
}

export interface FaqPreviousValuesSubscription
  extends Promise<AsyncIterator<FaqPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  desc: () => Promise<AsyncIterator<String>>;
}

export interface IssuesSubscriptionPayload {
  mutation: MutationType;
  node: Issues;
  updatedFields: String[];
  previousValues: IssuesPreviousValues;
}

export interface IssuesSubscriptionPayloadPromise
  extends Promise<IssuesSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = IssuesPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = IssuesPreviousValuesPromise>() => T;
}

export interface IssuesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<IssuesSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = IssuesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = IssuesPreviousValuesSubscription>() => T;
}

export interface IssuesPreviousValues {
  id: ID_Output;
  status?: String;
}

export interface IssuesPreviousValuesPromise
  extends Promise<IssuesPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<String>;
}

export interface IssuesPreviousValuesSubscription
  extends Promise<AsyncIterator<IssuesPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<String>>;
}

export interface JudgeSubscriptionPayload {
  mutation: MutationType;
  node: Judge;
  updatedFields: String[];
  previousValues: JudgePreviousValues;
}

export interface JudgeSubscriptionPayloadPromise
  extends Promise<JudgeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = JudgePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = JudgePreviousValuesPromise>() => T;
}

export interface JudgeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<JudgeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = JudgeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = JudgePreviousValuesSubscription>() => T;
}

export interface JudgePreviousValues {
  id: ID_Output;
  name: String;
  title: String;
  image: String;
  bio: String;
  dob?: DateTimeOutput;
  State: String;
  ctb: String;
  education: String;
  likes?: Int;
  remark: String;
}

export interface JudgePreviousValuesPromise
  extends Promise<JudgePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  title: () => Promise<String>;
  image: () => Promise<String>;
  bio: () => Promise<String>;
  dob: () => Promise<DateTimeOutput>;
  State: () => Promise<String>;
  ctb: () => Promise<String>;
  education: () => Promise<String>;
  likes: () => Promise<Int>;
  remark: () => Promise<String>;
}

export interface JudgePreviousValuesSubscription
  extends Promise<AsyncIterator<JudgePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  bio: () => Promise<AsyncIterator<String>>;
  dob: () => Promise<AsyncIterator<DateTimeOutput>>;
  State: () => Promise<AsyncIterator<String>>;
  ctb: () => Promise<AsyncIterator<String>>;
  education: () => Promise<AsyncIterator<String>>;
  likes: () => Promise<AsyncIterator<Int>>;
  remark: () => Promise<AsyncIterator<String>>;
}

export interface LocationSubscriptionPayload {
  mutation: MutationType;
  node: Location;
  updatedFields: String[];
  previousValues: LocationPreviousValues;
}

export interface LocationSubscriptionPayloadPromise
  extends Promise<LocationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LocationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LocationPreviousValuesPromise>() => T;
}

export interface LocationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LocationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LocationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LocationPreviousValuesSubscription>() => T;
}

export interface LocationPreviousValues {
  id: ID_Output;
  town?: String;
  state?: String;
}

export interface LocationPreviousValuesPromise
  extends Promise<LocationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  town: () => Promise<String>;
  state: () => Promise<String>;
}

export interface LocationPreviousValuesSubscription
  extends Promise<AsyncIterator<LocationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  town: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
}

export interface PostSubscriptionPayload {
  mutation: MutationType;
  node: Post;
  updatedFields: String[];
  previousValues: PostPreviousValues;
}

export interface PostSubscriptionPayloadPromise
  extends Promise<PostSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PostPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PostPreviousValuesPromise>() => T;
}

export interface PostSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PostSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PostSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PostPreviousValuesSubscription>() => T;
}

export interface PostPreviousValues {
  id: ID_Output;
  title?: String;
  category?: String;
  body?: String;
  image?: String;
  desc?: String;
  createdAt?: DateTimeOutput;
}

export interface PostPreviousValuesPromise
  extends Promise<PostPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  category: () => Promise<String>;
  body: () => Promise<String>;
  image: () => Promise<String>;
  desc: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface PostPreviousValuesSubscription
  extends Promise<AsyncIterator<PostPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  category: () => Promise<AsyncIterator<String>>;
  body: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  desc: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface QuestionSubscriptionPayload {
  mutation: MutationType;
  node: Question;
  updatedFields: String[];
  previousValues: QuestionPreviousValues;
}

export interface QuestionSubscriptionPayloadPromise
  extends Promise<QuestionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QuestionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QuestionPreviousValuesPromise>() => T;
}

export interface QuestionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QuestionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QuestionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QuestionPreviousValuesSubscription>() => T;
}

export interface QuestionPreviousValues {
  id: ID_Output;
  qns: String;
  ans: String;
}

export interface QuestionPreviousValuesPromise
  extends Promise<QuestionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  qns: () => Promise<String>;
  ans: () => Promise<String>;
}

export interface QuestionPreviousValuesSubscription
  extends Promise<AsyncIterator<QuestionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  qns: () => Promise<AsyncIterator<String>>;
  ans: () => Promise<AsyncIterator<String>>;
}

export interface RatiosSubscriptionPayload {
  mutation: MutationType;
  node: Ratios;
  updatedFields: String[];
  previousValues: RatiosPreviousValues;
}

export interface RatiosSubscriptionPayloadPromise
  extends Promise<RatiosSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RatiosPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RatiosPreviousValuesPromise>() => T;
}

export interface RatiosSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RatiosSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RatiosSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RatiosPreviousValuesSubscription>() => T;
}

export interface RatiosPreviousValues {
  id: ID_Output;
  heading?: String;
}

export interface RatiosPreviousValuesPromise
  extends Promise<RatiosPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  heading: () => Promise<String>;
}

export interface RatiosPreviousValuesSubscription
  extends Promise<AsyncIterator<RatiosPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  heading: () => Promise<AsyncIterator<String>>;
}

export interface ReportSubscriptionPayload {
  mutation: MutationType;
  node: Report;
  updatedFields: String[];
  previousValues: ReportPreviousValues;
}

export interface ReportSubscriptionPayloadPromise
  extends Promise<ReportSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ReportPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ReportPreviousValuesPromise>() => T;
}

export interface ReportSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReportSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ReportSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ReportPreviousValuesSubscription>() => T;
}

export interface ReportPreviousValues {
  id: ID_Output;
  year?: Int;
}

export interface ReportPreviousValuesPromise
  extends Promise<ReportPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  year: () => Promise<Int>;
}

export interface ReportPreviousValuesSubscription
  extends Promise<AsyncIterator<ReportPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  year: () => Promise<AsyncIterator<Int>>;
}

export interface SubSubscriptionPayload {
  mutation: MutationType;
  node: Sub;
  updatedFields: String[];
  previousValues: SubPreviousValues;
}

export interface SubSubscriptionPayloadPromise
  extends Promise<SubSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SubPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SubPreviousValuesPromise>() => T;
}

export interface SubSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SubSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SubSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SubPreviousValuesSubscription>() => T;
}

export interface SubPreviousValues {
  id: ID_Output;
  plan?: String;
  days?: Int;
  startedIn?: DateTimeOutput;
  expiresIn?: DateTimeOutput;
  isActive?: Boolean;
}

export interface SubPreviousValuesPromise
  extends Promise<SubPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  plan: () => Promise<String>;
  days: () => Promise<Int>;
  startedIn: () => Promise<DateTimeOutput>;
  expiresIn: () => Promise<DateTimeOutput>;
  isActive: () => Promise<Boolean>;
}

export interface SubPreviousValuesSubscription
  extends Promise<AsyncIterator<SubPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  plan: () => Promise<AsyncIterator<String>>;
  days: () => Promise<AsyncIterator<Int>>;
  startedIn: () => Promise<AsyncIterator<DateTimeOutput>>;
  expiresIn: () => Promise<AsyncIterator<DateTimeOutput>>;
  isActive: () => Promise<AsyncIterator<Boolean>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  name?: String;
  image?: String;
  username?: String;
  password: String;
  firstName: String;
  lastName: String;
  phone?: String;
  email: String;
  about?: String;
  company?: String;
  tac?: Boolean;
  resetPasswordToken?: String;
  resetPasswordExpires?: DateTimeOutput;
  isAdmin?: Boolean;
  emailConfirmationToken?: String;
  joinedDate?: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  image: () => Promise<String>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  phone: () => Promise<String>;
  email: () => Promise<String>;
  about: () => Promise<String>;
  company: () => Promise<String>;
  tac: () => Promise<Boolean>;
  resetPasswordToken: () => Promise<String>;
  resetPasswordExpires: () => Promise<DateTimeOutput>;
  isAdmin: () => Promise<Boolean>;
  emailConfirmationToken: () => Promise<String>;
  joinedDate: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  about: () => Promise<AsyncIterator<String>>;
  company: () => Promise<AsyncIterator<String>>;
  tac: () => Promise<AsyncIterator<Boolean>>;
  resetPasswordToken: () => Promise<AsyncIterator<String>>;
  resetPasswordExpires: () => Promise<AsyncIterator<DateTimeOutput>>;
  isAdmin: () => Promise<AsyncIterator<Boolean>>;
  emailConfirmationToken: () => Promise<AsyncIterator<String>>;
  joinedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface VolSubscriptionPayload {
  mutation: MutationType;
  node: Vol;
  updatedFields: String[];
  previousValues: VolPreviousValues;
}

export interface VolSubscriptionPayloadPromise
  extends Promise<VolSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VolPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VolPreviousValuesPromise>() => T;
}

export interface VolSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VolSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VolSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VolPreviousValuesSubscription>() => T;
}

export interface VolPreviousValues {
  id: ID_Output;
  part_no: Int;
  year: Int;
}

export interface VolPreviousValuesPromise
  extends Promise<VolPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  part_no: () => Promise<Int>;
  year: () => Promise<Int>;
}

export interface VolPreviousValuesSubscription
  extends Promise<AsyncIterator<VolPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  part_no: () => Promise<AsyncIterator<Int>>;
  year: () => Promise<AsyncIterator<Int>>;
}

export interface isActiveSubscriptionPayload {
  mutation: MutationType;
  node: isActive;
  updatedFields: String[];
  previousValues: isActivePreviousValues;
}

export interface isActiveSubscriptionPayloadPromise
  extends Promise<isActiveSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = isActivePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = isActivePreviousValuesPromise>() => T;
}

export interface isActiveSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<isActiveSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = isActiveSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = isActivePreviousValuesSubscription>() => T;
}

export interface isActivePreviousValues {
  id: ID_Output;
  status?: Boolean;
  activedOn?: DateTimeOutput;
}

export interface isActivePreviousValuesPromise
  extends Promise<isActivePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<Boolean>;
  activedOn: () => Promise<DateTimeOutput>;
}

export interface isActivePreviousValuesSubscription
  extends Promise<AsyncIterator<isActivePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<Boolean>>;
  activedOn: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Report",
    embedded: false
  },
  {
    name: "Vol",
    embedded: false
  },
  {
    name: "Category",
    embedded: false
  },
  {
    name: "Question",
    embedded: false
  },
  {
    name: "Faq",
    embedded: false
  },
  {
    name: "Judge",
    embedded: false
  },
  {
    name: "Counsel",
    embedded: false
  },
  {
    name: "Contents",
    embedded: false
  },
  {
    name: "Ratios",
    embedded: false
  },
  {
    name: "Issues",
    embedded: false
  },
  {
    name: "Cases",
    embedded: false
  },
  {
    name: "Location",
    embedded: false
  },
  {
    name: "Sub",
    embedded: false
  },
  {
    name: "isActive",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Comment",
    embedded: false
  },
  {
    name: "Post",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
