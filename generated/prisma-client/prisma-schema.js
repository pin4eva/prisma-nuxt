module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.8). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateCases {
  count: Int!
}

type AggregateCategory {
  count: Int!
}

type AggregateComment {
  count: Int!
}

type AggregateContents {
  count: Int!
}

type AggregateCounsel {
  count: Int!
}

type AggregateFaq {
  count: Int!
}

type AggregateisActive {
  count: Int!
}

type AggregateIssues {
  count: Int!
}

type AggregateJudge {
  count: Int!
}

type AggregateLocation {
  count: Int!
}

type AggregatePost {
  count: Int!
}

type AggregateQuestion {
  count: Int!
}

type AggregateRatios {
  count: Int!
}

type AggregateReport {
  count: Int!
}

type AggregateSub {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateVol {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Cases {
  id: ID!
  title: String!
  likes: Int
  appellant: String
  respondent: String
  suit_no: String
  page_no: String
  State: String
  cat: String
  judges(where: JudgeWhereInput, orderBy: JudgeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Judge!]
  counsel: Counsel
  vol: Vol!
  appeal: String
  court: String
  date: DateTime
  catchwords: String
  issues: Issues
  summary: String
  judgement: String
  cited: String
  books_cited: String
  determinations: String
}

type CasesConnection {
  pageInfo: PageInfo!
  edges: [CasesEdge]!
  aggregate: AggregateCases!
}

input CasesCreateInput {
  id: ID
  title: String!
  likes: Int
  appellant: String
  respondent: String
  suit_no: String
  page_no: String
  State: String
  cat: String
  judges: JudgeCreateManyWithoutCasesInput
  counsel: CounselCreateOneInput
  vol: VolCreateOneWithoutCasesInput!
  appeal: String
  court: String
  date: DateTime
  catchwords: String
  issues: IssuesCreateOneInput
  summary: String
  judgement: String
  cited: String
  books_cited: String
  determinations: String
}

input CasesCreateManyWithoutJudgesInput {
  create: [CasesCreateWithoutJudgesInput!]
  connect: [CasesWhereUniqueInput!]
}

input CasesCreateManyWithoutVolInput {
  create: [CasesCreateWithoutVolInput!]
  connect: [CasesWhereUniqueInput!]
}

input CasesCreateWithoutJudgesInput {
  id: ID
  title: String!
  likes: Int
  appellant: String
  respondent: String
  suit_no: String
  page_no: String
  State: String
  cat: String
  counsel: CounselCreateOneInput
  vol: VolCreateOneWithoutCasesInput!
  appeal: String
  court: String
  date: DateTime
  catchwords: String
  issues: IssuesCreateOneInput
  summary: String
  judgement: String
  cited: String
  books_cited: String
  determinations: String
}

input CasesCreateWithoutVolInput {
  id: ID
  title: String!
  likes: Int
  appellant: String
  respondent: String
  suit_no: String
  page_no: String
  State: String
  cat: String
  judges: JudgeCreateManyWithoutCasesInput
  counsel: CounselCreateOneInput
  appeal: String
  court: String
  date: DateTime
  catchwords: String
  issues: IssuesCreateOneInput
  summary: String
  judgement: String
  cited: String
  books_cited: String
  determinations: String
}

type CasesEdge {
  node: Cases!
  cursor: String!
}

enum CasesOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  likes_ASC
  likes_DESC
  appellant_ASC
  appellant_DESC
  respondent_ASC
  respondent_DESC
  suit_no_ASC
  suit_no_DESC
  page_no_ASC
  page_no_DESC
  State_ASC
  State_DESC
  cat_ASC
  cat_DESC
  appeal_ASC
  appeal_DESC
  court_ASC
  court_DESC
  date_ASC
  date_DESC
  catchwords_ASC
  catchwords_DESC
  summary_ASC
  summary_DESC
  judgement_ASC
  judgement_DESC
  cited_ASC
  cited_DESC
  books_cited_ASC
  books_cited_DESC
  determinations_ASC
  determinations_DESC
}

type CasesPreviousValues {
  id: ID!
  title: String!
  likes: Int
  appellant: String
  respondent: String
  suit_no: String
  page_no: String
  State: String
  cat: String
  appeal: String
  court: String
  date: DateTime
  catchwords: String
  summary: String
  judgement: String
  cited: String
  books_cited: String
  determinations: String
}

input CasesScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  likes: Int
  likes_not: Int
  likes_in: [Int!]
  likes_not_in: [Int!]
  likes_lt: Int
  likes_lte: Int
  likes_gt: Int
  likes_gte: Int
  appellant: String
  appellant_not: String
  appellant_in: [String!]
  appellant_not_in: [String!]
  appellant_lt: String
  appellant_lte: String
  appellant_gt: String
  appellant_gte: String
  appellant_contains: String
  appellant_not_contains: String
  appellant_starts_with: String
  appellant_not_starts_with: String
  appellant_ends_with: String
  appellant_not_ends_with: String
  respondent: String
  respondent_not: String
  respondent_in: [String!]
  respondent_not_in: [String!]
  respondent_lt: String
  respondent_lte: String
  respondent_gt: String
  respondent_gte: String
  respondent_contains: String
  respondent_not_contains: String
  respondent_starts_with: String
  respondent_not_starts_with: String
  respondent_ends_with: String
  respondent_not_ends_with: String
  suit_no: String
  suit_no_not: String
  suit_no_in: [String!]
  suit_no_not_in: [String!]
  suit_no_lt: String
  suit_no_lte: String
  suit_no_gt: String
  suit_no_gte: String
  suit_no_contains: String
  suit_no_not_contains: String
  suit_no_starts_with: String
  suit_no_not_starts_with: String
  suit_no_ends_with: String
  suit_no_not_ends_with: String
  page_no: String
  page_no_not: String
  page_no_in: [String!]
  page_no_not_in: [String!]
  page_no_lt: String
  page_no_lte: String
  page_no_gt: String
  page_no_gte: String
  page_no_contains: String
  page_no_not_contains: String
  page_no_starts_with: String
  page_no_not_starts_with: String
  page_no_ends_with: String
  page_no_not_ends_with: String
  State: String
  State_not: String
  State_in: [String!]
  State_not_in: [String!]
  State_lt: String
  State_lte: String
  State_gt: String
  State_gte: String
  State_contains: String
  State_not_contains: String
  State_starts_with: String
  State_not_starts_with: String
  State_ends_with: String
  State_not_ends_with: String
  cat: String
  cat_not: String
  cat_in: [String!]
  cat_not_in: [String!]
  cat_lt: String
  cat_lte: String
  cat_gt: String
  cat_gte: String
  cat_contains: String
  cat_not_contains: String
  cat_starts_with: String
  cat_not_starts_with: String
  cat_ends_with: String
  cat_not_ends_with: String
  appeal: String
  appeal_not: String
  appeal_in: [String!]
  appeal_not_in: [String!]
  appeal_lt: String
  appeal_lte: String
  appeal_gt: String
  appeal_gte: String
  appeal_contains: String
  appeal_not_contains: String
  appeal_starts_with: String
  appeal_not_starts_with: String
  appeal_ends_with: String
  appeal_not_ends_with: String
  court: String
  court_not: String
  court_in: [String!]
  court_not_in: [String!]
  court_lt: String
  court_lte: String
  court_gt: String
  court_gte: String
  court_contains: String
  court_not_contains: String
  court_starts_with: String
  court_not_starts_with: String
  court_ends_with: String
  court_not_ends_with: String
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  catchwords: String
  catchwords_not: String
  catchwords_in: [String!]
  catchwords_not_in: [String!]
  catchwords_lt: String
  catchwords_lte: String
  catchwords_gt: String
  catchwords_gte: String
  catchwords_contains: String
  catchwords_not_contains: String
  catchwords_starts_with: String
  catchwords_not_starts_with: String
  catchwords_ends_with: String
  catchwords_not_ends_with: String
  summary: String
  summary_not: String
  summary_in: [String!]
  summary_not_in: [String!]
  summary_lt: String
  summary_lte: String
  summary_gt: String
  summary_gte: String
  summary_contains: String
  summary_not_contains: String
  summary_starts_with: String
  summary_not_starts_with: String
  summary_ends_with: String
  summary_not_ends_with: String
  judgement: String
  judgement_not: String
  judgement_in: [String!]
  judgement_not_in: [String!]
  judgement_lt: String
  judgement_lte: String
  judgement_gt: String
  judgement_gte: String
  judgement_contains: String
  judgement_not_contains: String
  judgement_starts_with: String
  judgement_not_starts_with: String
  judgement_ends_with: String
  judgement_not_ends_with: String
  cited: String
  cited_not: String
  cited_in: [String!]
  cited_not_in: [String!]
  cited_lt: String
  cited_lte: String
  cited_gt: String
  cited_gte: String
  cited_contains: String
  cited_not_contains: String
  cited_starts_with: String
  cited_not_starts_with: String
  cited_ends_with: String
  cited_not_ends_with: String
  books_cited: String
  books_cited_not: String
  books_cited_in: [String!]
  books_cited_not_in: [String!]
  books_cited_lt: String
  books_cited_lte: String
  books_cited_gt: String
  books_cited_gte: String
  books_cited_contains: String
  books_cited_not_contains: String
  books_cited_starts_with: String
  books_cited_not_starts_with: String
  books_cited_ends_with: String
  books_cited_not_ends_with: String
  determinations: String
  determinations_not: String
  determinations_in: [String!]
  determinations_not_in: [String!]
  determinations_lt: String
  determinations_lte: String
  determinations_gt: String
  determinations_gte: String
  determinations_contains: String
  determinations_not_contains: String
  determinations_starts_with: String
  determinations_not_starts_with: String
  determinations_ends_with: String
  determinations_not_ends_with: String
  AND: [CasesScalarWhereInput!]
  OR: [CasesScalarWhereInput!]
  NOT: [CasesScalarWhereInput!]
}

type CasesSubscriptionPayload {
  mutation: MutationType!
  node: Cases
  updatedFields: [String!]
  previousValues: CasesPreviousValues
}

input CasesSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CasesWhereInput
  AND: [CasesSubscriptionWhereInput!]
  OR: [CasesSubscriptionWhereInput!]
  NOT: [CasesSubscriptionWhereInput!]
}

input CasesUpdateInput {
  title: String
  likes: Int
  appellant: String
  respondent: String
  suit_no: String
  page_no: String
  State: String
  cat: String
  judges: JudgeUpdateManyWithoutCasesInput
  counsel: CounselUpdateOneInput
  vol: VolUpdateOneRequiredWithoutCasesInput
  appeal: String
  court: String
  date: DateTime
  catchwords: String
  issues: IssuesUpdateOneInput
  summary: String
  judgement: String
  cited: String
  books_cited: String
  determinations: String
}

input CasesUpdateManyDataInput {
  title: String
  likes: Int
  appellant: String
  respondent: String
  suit_no: String
  page_no: String
  State: String
  cat: String
  appeal: String
  court: String
  date: DateTime
  catchwords: String
  summary: String
  judgement: String
  cited: String
  books_cited: String
  determinations: String
}

input CasesUpdateManyMutationInput {
  title: String
  likes: Int
  appellant: String
  respondent: String
  suit_no: String
  page_no: String
  State: String
  cat: String
  appeal: String
  court: String
  date: DateTime
  catchwords: String
  summary: String
  judgement: String
  cited: String
  books_cited: String
  determinations: String
}

input CasesUpdateManyWithoutJudgesInput {
  create: [CasesCreateWithoutJudgesInput!]
  delete: [CasesWhereUniqueInput!]
  connect: [CasesWhereUniqueInput!]
  set: [CasesWhereUniqueInput!]
  disconnect: [CasesWhereUniqueInput!]
  update: [CasesUpdateWithWhereUniqueWithoutJudgesInput!]
  upsert: [CasesUpsertWithWhereUniqueWithoutJudgesInput!]
  deleteMany: [CasesScalarWhereInput!]
  updateMany: [CasesUpdateManyWithWhereNestedInput!]
}

input CasesUpdateManyWithoutVolInput {
  create: [CasesCreateWithoutVolInput!]
  delete: [CasesWhereUniqueInput!]
  connect: [CasesWhereUniqueInput!]
  set: [CasesWhereUniqueInput!]
  disconnect: [CasesWhereUniqueInput!]
  update: [CasesUpdateWithWhereUniqueWithoutVolInput!]
  upsert: [CasesUpsertWithWhereUniqueWithoutVolInput!]
  deleteMany: [CasesScalarWhereInput!]
  updateMany: [CasesUpdateManyWithWhereNestedInput!]
}

input CasesUpdateManyWithWhereNestedInput {
  where: CasesScalarWhereInput!
  data: CasesUpdateManyDataInput!
}

input CasesUpdateWithoutJudgesDataInput {
  title: String
  likes: Int
  appellant: String
  respondent: String
  suit_no: String
  page_no: String
  State: String
  cat: String
  counsel: CounselUpdateOneInput
  vol: VolUpdateOneRequiredWithoutCasesInput
  appeal: String
  court: String
  date: DateTime
  catchwords: String
  issues: IssuesUpdateOneInput
  summary: String
  judgement: String
  cited: String
  books_cited: String
  determinations: String
}

input CasesUpdateWithoutVolDataInput {
  title: String
  likes: Int
  appellant: String
  respondent: String
  suit_no: String
  page_no: String
  State: String
  cat: String
  judges: JudgeUpdateManyWithoutCasesInput
  counsel: CounselUpdateOneInput
  appeal: String
  court: String
  date: DateTime
  catchwords: String
  issues: IssuesUpdateOneInput
  summary: String
  judgement: String
  cited: String
  books_cited: String
  determinations: String
}

input CasesUpdateWithWhereUniqueWithoutJudgesInput {
  where: CasesWhereUniqueInput!
  data: CasesUpdateWithoutJudgesDataInput!
}

input CasesUpdateWithWhereUniqueWithoutVolInput {
  where: CasesWhereUniqueInput!
  data: CasesUpdateWithoutVolDataInput!
}

input CasesUpsertWithWhereUniqueWithoutJudgesInput {
  where: CasesWhereUniqueInput!
  update: CasesUpdateWithoutJudgesDataInput!
  create: CasesCreateWithoutJudgesInput!
}

input CasesUpsertWithWhereUniqueWithoutVolInput {
  where: CasesWhereUniqueInput!
  update: CasesUpdateWithoutVolDataInput!
  create: CasesCreateWithoutVolInput!
}

input CasesWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  likes: Int
  likes_not: Int
  likes_in: [Int!]
  likes_not_in: [Int!]
  likes_lt: Int
  likes_lte: Int
  likes_gt: Int
  likes_gte: Int
  appellant: String
  appellant_not: String
  appellant_in: [String!]
  appellant_not_in: [String!]
  appellant_lt: String
  appellant_lte: String
  appellant_gt: String
  appellant_gte: String
  appellant_contains: String
  appellant_not_contains: String
  appellant_starts_with: String
  appellant_not_starts_with: String
  appellant_ends_with: String
  appellant_not_ends_with: String
  respondent: String
  respondent_not: String
  respondent_in: [String!]
  respondent_not_in: [String!]
  respondent_lt: String
  respondent_lte: String
  respondent_gt: String
  respondent_gte: String
  respondent_contains: String
  respondent_not_contains: String
  respondent_starts_with: String
  respondent_not_starts_with: String
  respondent_ends_with: String
  respondent_not_ends_with: String
  suit_no: String
  suit_no_not: String
  suit_no_in: [String!]
  suit_no_not_in: [String!]
  suit_no_lt: String
  suit_no_lte: String
  suit_no_gt: String
  suit_no_gte: String
  suit_no_contains: String
  suit_no_not_contains: String
  suit_no_starts_with: String
  suit_no_not_starts_with: String
  suit_no_ends_with: String
  suit_no_not_ends_with: String
  page_no: String
  page_no_not: String
  page_no_in: [String!]
  page_no_not_in: [String!]
  page_no_lt: String
  page_no_lte: String
  page_no_gt: String
  page_no_gte: String
  page_no_contains: String
  page_no_not_contains: String
  page_no_starts_with: String
  page_no_not_starts_with: String
  page_no_ends_with: String
  page_no_not_ends_with: String
  State: String
  State_not: String
  State_in: [String!]
  State_not_in: [String!]
  State_lt: String
  State_lte: String
  State_gt: String
  State_gte: String
  State_contains: String
  State_not_contains: String
  State_starts_with: String
  State_not_starts_with: String
  State_ends_with: String
  State_not_ends_with: String
  cat: String
  cat_not: String
  cat_in: [String!]
  cat_not_in: [String!]
  cat_lt: String
  cat_lte: String
  cat_gt: String
  cat_gte: String
  cat_contains: String
  cat_not_contains: String
  cat_starts_with: String
  cat_not_starts_with: String
  cat_ends_with: String
  cat_not_ends_with: String
  judges_every: JudgeWhereInput
  judges_some: JudgeWhereInput
  judges_none: JudgeWhereInput
  counsel: CounselWhereInput
  vol: VolWhereInput
  appeal: String
  appeal_not: String
  appeal_in: [String!]
  appeal_not_in: [String!]
  appeal_lt: String
  appeal_lte: String
  appeal_gt: String
  appeal_gte: String
  appeal_contains: String
  appeal_not_contains: String
  appeal_starts_with: String
  appeal_not_starts_with: String
  appeal_ends_with: String
  appeal_not_ends_with: String
  court: String
  court_not: String
  court_in: [String!]
  court_not_in: [String!]
  court_lt: String
  court_lte: String
  court_gt: String
  court_gte: String
  court_contains: String
  court_not_contains: String
  court_starts_with: String
  court_not_starts_with: String
  court_ends_with: String
  court_not_ends_with: String
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  catchwords: String
  catchwords_not: String
  catchwords_in: [String!]
  catchwords_not_in: [String!]
  catchwords_lt: String
  catchwords_lte: String
  catchwords_gt: String
  catchwords_gte: String
  catchwords_contains: String
  catchwords_not_contains: String
  catchwords_starts_with: String
  catchwords_not_starts_with: String
  catchwords_ends_with: String
  catchwords_not_ends_with: String
  issues: IssuesWhereInput
  summary: String
  summary_not: String
  summary_in: [String!]
  summary_not_in: [String!]
  summary_lt: String
  summary_lte: String
  summary_gt: String
  summary_gte: String
  summary_contains: String
  summary_not_contains: String
  summary_starts_with: String
  summary_not_starts_with: String
  summary_ends_with: String
  summary_not_ends_with: String
  judgement: String
  judgement_not: String
  judgement_in: [String!]
  judgement_not_in: [String!]
  judgement_lt: String
  judgement_lte: String
  judgement_gt: String
  judgement_gte: String
  judgement_contains: String
  judgement_not_contains: String
  judgement_starts_with: String
  judgement_not_starts_with: String
  judgement_ends_with: String
  judgement_not_ends_with: String
  cited: String
  cited_not: String
  cited_in: [String!]
  cited_not_in: [String!]
  cited_lt: String
  cited_lte: String
  cited_gt: String
  cited_gte: String
  cited_contains: String
  cited_not_contains: String
  cited_starts_with: String
  cited_not_starts_with: String
  cited_ends_with: String
  cited_not_ends_with: String
  books_cited: String
  books_cited_not: String
  books_cited_in: [String!]
  books_cited_not_in: [String!]
  books_cited_lt: String
  books_cited_lte: String
  books_cited_gt: String
  books_cited_gte: String
  books_cited_contains: String
  books_cited_not_contains: String
  books_cited_starts_with: String
  books_cited_not_starts_with: String
  books_cited_ends_with: String
  books_cited_not_ends_with: String
  determinations: String
  determinations_not: String
  determinations_in: [String!]
  determinations_not_in: [String!]
  determinations_lt: String
  determinations_lte: String
  determinations_gt: String
  determinations_gte: String
  determinations_contains: String
  determinations_not_contains: String
  determinations_starts_with: String
  determinations_not_starts_with: String
  determinations_ends_with: String
  determinations_not_ends_with: String
  AND: [CasesWhereInput!]
  OR: [CasesWhereInput!]
  NOT: [CasesWhereInput!]
}

input CasesWhereUniqueInput {
  id: ID
}

type Category {
  id: ID!
  category: String!
  desc: String!
  createdAt: DateTime
  faq(where: FaqWhereInput, orderBy: FaqOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Faq!]
}

type CategoryConnection {
  pageInfo: PageInfo!
  edges: [CategoryEdge]!
  aggregate: AggregateCategory!
}

input CategoryCreateInput {
  id: ID
  category: String!
  desc: String!
  faq: FaqCreateManyWithoutCategoryInput
}

input CategoryCreateOneWithoutFaqInput {
  create: CategoryCreateWithoutFaqInput
  connect: CategoryWhereUniqueInput
}

input CategoryCreateWithoutFaqInput {
  id: ID
  category: String!
  desc: String!
}

type CategoryEdge {
  node: Category!
  cursor: String!
}

enum CategoryOrderByInput {
  id_ASC
  id_DESC
  category_ASC
  category_DESC
  desc_ASC
  desc_DESC
  createdAt_ASC
  createdAt_DESC
}

type CategoryPreviousValues {
  id: ID!
  category: String!
  desc: String!
  createdAt: DateTime
}

type CategorySubscriptionPayload {
  mutation: MutationType!
  node: Category
  updatedFields: [String!]
  previousValues: CategoryPreviousValues
}

input CategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CategoryWhereInput
  AND: [CategorySubscriptionWhereInput!]
  OR: [CategorySubscriptionWhereInput!]
  NOT: [CategorySubscriptionWhereInput!]
}

input CategoryUpdateInput {
  category: String
  desc: String
  faq: FaqUpdateManyWithoutCategoryInput
}

input CategoryUpdateManyMutationInput {
  category: String
  desc: String
}

input CategoryUpdateOneRequiredWithoutFaqInput {
  create: CategoryCreateWithoutFaqInput
  update: CategoryUpdateWithoutFaqDataInput
  upsert: CategoryUpsertWithoutFaqInput
  connect: CategoryWhereUniqueInput
}

input CategoryUpdateWithoutFaqDataInput {
  category: String
  desc: String
}

input CategoryUpsertWithoutFaqInput {
  update: CategoryUpdateWithoutFaqDataInput!
  create: CategoryCreateWithoutFaqInput!
}

input CategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  category: String
  category_not: String
  category_in: [String!]
  category_not_in: [String!]
  category_lt: String
  category_lte: String
  category_gt: String
  category_gte: String
  category_contains: String
  category_not_contains: String
  category_starts_with: String
  category_not_starts_with: String
  category_ends_with: String
  category_not_ends_with: String
  desc: String
  desc_not: String
  desc_in: [String!]
  desc_not_in: [String!]
  desc_lt: String
  desc_lte: String
  desc_gt: String
  desc_gte: String
  desc_contains: String
  desc_not_contains: String
  desc_starts_with: String
  desc_not_starts_with: String
  desc_ends_with: String
  desc_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  faq_every: FaqWhereInput
  faq_some: FaqWhereInput
  faq_none: FaqWhereInput
  AND: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
}

input CategoryWhereUniqueInput {
  id: ID
}

type Comment {
  id: ID!
  body: String
  createdAt: DateTime
  author: User
}

type CommentConnection {
  pageInfo: PageInfo!
  edges: [CommentEdge]!
  aggregate: AggregateComment!
}

input CommentCreateInput {
  id: ID
  body: String
  author: UserCreateOneInput
}

input CommentCreateManyInput {
  create: [CommentCreateInput!]
  connect: [CommentWhereUniqueInput!]
}

type CommentEdge {
  node: Comment!
  cursor: String!
}

enum CommentOrderByInput {
  id_ASC
  id_DESC
  body_ASC
  body_DESC
  createdAt_ASC
  createdAt_DESC
}

type CommentPreviousValues {
  id: ID!
  body: String
  createdAt: DateTime
}

input CommentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  body: String
  body_not: String
  body_in: [String!]
  body_not_in: [String!]
  body_lt: String
  body_lte: String
  body_gt: String
  body_gte: String
  body_contains: String
  body_not_contains: String
  body_starts_with: String
  body_not_starts_with: String
  body_ends_with: String
  body_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [CommentScalarWhereInput!]
  OR: [CommentScalarWhereInput!]
  NOT: [CommentScalarWhereInput!]
}

type CommentSubscriptionPayload {
  mutation: MutationType!
  node: Comment
  updatedFields: [String!]
  previousValues: CommentPreviousValues
}

input CommentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CommentWhereInput
  AND: [CommentSubscriptionWhereInput!]
  OR: [CommentSubscriptionWhereInput!]
  NOT: [CommentSubscriptionWhereInput!]
}

input CommentUpdateDataInput {
  body: String
  author: UserUpdateOneInput
}

input CommentUpdateInput {
  body: String
  author: UserUpdateOneInput
}

input CommentUpdateManyDataInput {
  body: String
}

input CommentUpdateManyInput {
  create: [CommentCreateInput!]
  update: [CommentUpdateWithWhereUniqueNestedInput!]
  upsert: [CommentUpsertWithWhereUniqueNestedInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  deleteMany: [CommentScalarWhereInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
}

input CommentUpdateManyMutationInput {
  body: String
}

input CommentUpdateManyWithWhereNestedInput {
  where: CommentScalarWhereInput!
  data: CommentUpdateManyDataInput!
}

input CommentUpdateWithWhereUniqueNestedInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateDataInput!
}

input CommentUpsertWithWhereUniqueNestedInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateDataInput!
  create: CommentCreateInput!
}

input CommentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  body: String
  body_not: String
  body_in: [String!]
  body_not_in: [String!]
  body_lt: String
  body_lte: String
  body_gt: String
  body_gte: String
  body_contains: String
  body_not_contains: String
  body_starts_with: String
  body_not_starts_with: String
  body_ends_with: String
  body_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  author: UserWhereInput
  AND: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  NOT: [CommentWhereInput!]
}

input CommentWhereUniqueInput {
  id: ID
}

type Contents {
  id: ID!
  quoted: Judge
  ref: String
  body: String
}

type ContentsConnection {
  pageInfo: PageInfo!
  edges: [ContentsEdge]!
  aggregate: AggregateContents!
}

input ContentsCreateInput {
  id: ID
  quoted: JudgeCreateOneInput
  ref: String
  body: String
}

input ContentsCreateOneInput {
  create: ContentsCreateInput
  connect: ContentsWhereUniqueInput
}

type ContentsEdge {
  node: Contents!
  cursor: String!
}

enum ContentsOrderByInput {
  id_ASC
  id_DESC
  ref_ASC
  ref_DESC
  body_ASC
  body_DESC
}

type ContentsPreviousValues {
  id: ID!
  ref: String
  body: String
}

type ContentsSubscriptionPayload {
  mutation: MutationType!
  node: Contents
  updatedFields: [String!]
  previousValues: ContentsPreviousValues
}

input ContentsSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ContentsWhereInput
  AND: [ContentsSubscriptionWhereInput!]
  OR: [ContentsSubscriptionWhereInput!]
  NOT: [ContentsSubscriptionWhereInput!]
}

input ContentsUpdateDataInput {
  quoted: JudgeUpdateOneInput
  ref: String
  body: String
}

input ContentsUpdateInput {
  quoted: JudgeUpdateOneInput
  ref: String
  body: String
}

input ContentsUpdateManyMutationInput {
  ref: String
  body: String
}

input ContentsUpdateOneInput {
  create: ContentsCreateInput
  update: ContentsUpdateDataInput
  upsert: ContentsUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ContentsWhereUniqueInput
}

input ContentsUpsertNestedInput {
  update: ContentsUpdateDataInput!
  create: ContentsCreateInput!
}

input ContentsWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  quoted: JudgeWhereInput
  ref: String
  ref_not: String
  ref_in: [String!]
  ref_not_in: [String!]
  ref_lt: String
  ref_lte: String
  ref_gt: String
  ref_gte: String
  ref_contains: String
  ref_not_contains: String
  ref_starts_with: String
  ref_not_starts_with: String
  ref_ends_with: String
  ref_not_ends_with: String
  body: String
  body_not: String
  body_in: [String!]
  body_not_in: [String!]
  body_lt: String
  body_lte: String
  body_gt: String
  body_gte: String
  body_contains: String
  body_not_contains: String
  body_starts_with: String
  body_not_starts_with: String
  body_ends_with: String
  body_not_ends_with: String
  AND: [ContentsWhereInput!]
  OR: [ContentsWhereInput!]
  NOT: [ContentsWhereInput!]
}

input ContentsWhereUniqueInput {
  id: ID
}

type Counsel {
  id: ID!
  appellant: String
  respondent: String
}

type CounselConnection {
  pageInfo: PageInfo!
  edges: [CounselEdge]!
  aggregate: AggregateCounsel!
}

input CounselCreateInput {
  id: ID
  appellant: String
  respondent: String
}

input CounselCreateOneInput {
  create: CounselCreateInput
  connect: CounselWhereUniqueInput
}

type CounselEdge {
  node: Counsel!
  cursor: String!
}

enum CounselOrderByInput {
  id_ASC
  id_DESC
  appellant_ASC
  appellant_DESC
  respondent_ASC
  respondent_DESC
}

type CounselPreviousValues {
  id: ID!
  appellant: String
  respondent: String
}

type CounselSubscriptionPayload {
  mutation: MutationType!
  node: Counsel
  updatedFields: [String!]
  previousValues: CounselPreviousValues
}

input CounselSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CounselWhereInput
  AND: [CounselSubscriptionWhereInput!]
  OR: [CounselSubscriptionWhereInput!]
  NOT: [CounselSubscriptionWhereInput!]
}

input CounselUpdateDataInput {
  appellant: String
  respondent: String
}

input CounselUpdateInput {
  appellant: String
  respondent: String
}

input CounselUpdateManyMutationInput {
  appellant: String
  respondent: String
}

input CounselUpdateOneInput {
  create: CounselCreateInput
  update: CounselUpdateDataInput
  upsert: CounselUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: CounselWhereUniqueInput
}

input CounselUpsertNestedInput {
  update: CounselUpdateDataInput!
  create: CounselCreateInput!
}

input CounselWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  appellant: String
  appellant_not: String
  appellant_in: [String!]
  appellant_not_in: [String!]
  appellant_lt: String
  appellant_lte: String
  appellant_gt: String
  appellant_gte: String
  appellant_contains: String
  appellant_not_contains: String
  appellant_starts_with: String
  appellant_not_starts_with: String
  appellant_ends_with: String
  appellant_not_ends_with: String
  respondent: String
  respondent_not: String
  respondent_in: [String!]
  respondent_not_in: [String!]
  respondent_lt: String
  respondent_lte: String
  respondent_gt: String
  respondent_gte: String
  respondent_contains: String
  respondent_not_contains: String
  respondent_starts_with: String
  respondent_not_starts_with: String
  respondent_ends_with: String
  respondent_not_ends_with: String
  AND: [CounselWhereInput!]
  OR: [CounselWhereInput!]
  NOT: [CounselWhereInput!]
}

input CounselWhereUniqueInput {
  id: ID
}

scalar DateTime

type Faq {
  id: ID!
  title: String!
  category: Category!
  createdAt: DateTime
  desc: String!
  questions(where: QuestionWhereInput, orderBy: QuestionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Question!]
}

type FaqConnection {
  pageInfo: PageInfo!
  edges: [FaqEdge]!
  aggregate: AggregateFaq!
}

input FaqCreateInput {
  id: ID
  title: String!
  category: CategoryCreateOneWithoutFaqInput!
  desc: String!
  questions: QuestionCreateManyInput
}

input FaqCreateManyWithoutCategoryInput {
  create: [FaqCreateWithoutCategoryInput!]
  connect: [FaqWhereUniqueInput!]
}

input FaqCreateWithoutCategoryInput {
  id: ID
  title: String!
  desc: String!
  questions: QuestionCreateManyInput
}

type FaqEdge {
  node: Faq!
  cursor: String!
}

enum FaqOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  createdAt_ASC
  createdAt_DESC
  desc_ASC
  desc_DESC
}

type FaqPreviousValues {
  id: ID!
  title: String!
  createdAt: DateTime
  desc: String!
}

input FaqScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  desc: String
  desc_not: String
  desc_in: [String!]
  desc_not_in: [String!]
  desc_lt: String
  desc_lte: String
  desc_gt: String
  desc_gte: String
  desc_contains: String
  desc_not_contains: String
  desc_starts_with: String
  desc_not_starts_with: String
  desc_ends_with: String
  desc_not_ends_with: String
  AND: [FaqScalarWhereInput!]
  OR: [FaqScalarWhereInput!]
  NOT: [FaqScalarWhereInput!]
}

type FaqSubscriptionPayload {
  mutation: MutationType!
  node: Faq
  updatedFields: [String!]
  previousValues: FaqPreviousValues
}

input FaqSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FaqWhereInput
  AND: [FaqSubscriptionWhereInput!]
  OR: [FaqSubscriptionWhereInput!]
  NOT: [FaqSubscriptionWhereInput!]
}

input FaqUpdateInput {
  title: String
  category: CategoryUpdateOneRequiredWithoutFaqInput
  desc: String
  questions: QuestionUpdateManyInput
}

input FaqUpdateManyDataInput {
  title: String
  desc: String
}

input FaqUpdateManyMutationInput {
  title: String
  desc: String
}

input FaqUpdateManyWithoutCategoryInput {
  create: [FaqCreateWithoutCategoryInput!]
  delete: [FaqWhereUniqueInput!]
  connect: [FaqWhereUniqueInput!]
  set: [FaqWhereUniqueInput!]
  disconnect: [FaqWhereUniqueInput!]
  update: [FaqUpdateWithWhereUniqueWithoutCategoryInput!]
  upsert: [FaqUpsertWithWhereUniqueWithoutCategoryInput!]
  deleteMany: [FaqScalarWhereInput!]
  updateMany: [FaqUpdateManyWithWhereNestedInput!]
}

input FaqUpdateManyWithWhereNestedInput {
  where: FaqScalarWhereInput!
  data: FaqUpdateManyDataInput!
}

input FaqUpdateWithoutCategoryDataInput {
  title: String
  desc: String
  questions: QuestionUpdateManyInput
}

input FaqUpdateWithWhereUniqueWithoutCategoryInput {
  where: FaqWhereUniqueInput!
  data: FaqUpdateWithoutCategoryDataInput!
}

input FaqUpsertWithWhereUniqueWithoutCategoryInput {
  where: FaqWhereUniqueInput!
  update: FaqUpdateWithoutCategoryDataInput!
  create: FaqCreateWithoutCategoryInput!
}

input FaqWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  category: CategoryWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  desc: String
  desc_not: String
  desc_in: [String!]
  desc_not_in: [String!]
  desc_lt: String
  desc_lte: String
  desc_gt: String
  desc_gte: String
  desc_contains: String
  desc_not_contains: String
  desc_starts_with: String
  desc_not_starts_with: String
  desc_ends_with: String
  desc_not_ends_with: String
  questions_every: QuestionWhereInput
  questions_some: QuestionWhereInput
  questions_none: QuestionWhereInput
  AND: [FaqWhereInput!]
  OR: [FaqWhereInput!]
  NOT: [FaqWhereInput!]
}

input FaqWhereUniqueInput {
  id: ID
}

type isActive {
  id: ID!
  status: Boolean
  activedOn: DateTime
}

type isActiveConnection {
  pageInfo: PageInfo!
  edges: [isActiveEdge]!
  aggregate: AggregateisActive!
}

input isActiveCreateInput {
  id: ID
  status: Boolean
  activedOn: DateTime
}

input isActiveCreateOneInput {
  create: isActiveCreateInput
  connect: isActiveWhereUniqueInput
}

type isActiveEdge {
  node: isActive!
  cursor: String!
}

enum isActiveOrderByInput {
  id_ASC
  id_DESC
  status_ASC
  status_DESC
  activedOn_ASC
  activedOn_DESC
}

type isActivePreviousValues {
  id: ID!
  status: Boolean
  activedOn: DateTime
}

type isActiveSubscriptionPayload {
  mutation: MutationType!
  node: isActive
  updatedFields: [String!]
  previousValues: isActivePreviousValues
}

input isActiveSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: isActiveWhereInput
  AND: [isActiveSubscriptionWhereInput!]
  OR: [isActiveSubscriptionWhereInput!]
  NOT: [isActiveSubscriptionWhereInput!]
}

input isActiveUpdateDataInput {
  status: Boolean
  activedOn: DateTime
}

input isActiveUpdateInput {
  status: Boolean
  activedOn: DateTime
}

input isActiveUpdateManyMutationInput {
  status: Boolean
  activedOn: DateTime
}

input isActiveUpdateOneInput {
  create: isActiveCreateInput
  update: isActiveUpdateDataInput
  upsert: isActiveUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: isActiveWhereUniqueInput
}

input isActiveUpsertNestedInput {
  update: isActiveUpdateDataInput!
  create: isActiveCreateInput!
}

input isActiveWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  status: Boolean
  status_not: Boolean
  activedOn: DateTime
  activedOn_not: DateTime
  activedOn_in: [DateTime!]
  activedOn_not_in: [DateTime!]
  activedOn_lt: DateTime
  activedOn_lte: DateTime
  activedOn_gt: DateTime
  activedOn_gte: DateTime
  AND: [isActiveWhereInput!]
  OR: [isActiveWhereInput!]
  NOT: [isActiveWhereInput!]
}

input isActiveWhereUniqueInput {
  id: ID
}

type Issues {
  id: ID!
  status: String
  ratios(where: RatiosWhereInput, orderBy: RatiosOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Ratios!]
}

type IssuesConnection {
  pageInfo: PageInfo!
  edges: [IssuesEdge]!
  aggregate: AggregateIssues!
}

input IssuesCreateInput {
  id: ID
  status: String
  ratios: RatiosCreateManyInput
}

input IssuesCreateOneInput {
  create: IssuesCreateInput
  connect: IssuesWhereUniqueInput
}

type IssuesEdge {
  node: Issues!
  cursor: String!
}

enum IssuesOrderByInput {
  id_ASC
  id_DESC
  status_ASC
  status_DESC
}

type IssuesPreviousValues {
  id: ID!
  status: String
}

type IssuesSubscriptionPayload {
  mutation: MutationType!
  node: Issues
  updatedFields: [String!]
  previousValues: IssuesPreviousValues
}

input IssuesSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: IssuesWhereInput
  AND: [IssuesSubscriptionWhereInput!]
  OR: [IssuesSubscriptionWhereInput!]
  NOT: [IssuesSubscriptionWhereInput!]
}

input IssuesUpdateDataInput {
  status: String
  ratios: RatiosUpdateManyInput
}

input IssuesUpdateInput {
  status: String
  ratios: RatiosUpdateManyInput
}

input IssuesUpdateManyMutationInput {
  status: String
}

input IssuesUpdateOneInput {
  create: IssuesCreateInput
  update: IssuesUpdateDataInput
  upsert: IssuesUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: IssuesWhereUniqueInput
}

input IssuesUpsertNestedInput {
  update: IssuesUpdateDataInput!
  create: IssuesCreateInput!
}

input IssuesWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  status: String
  status_not: String
  status_in: [String!]
  status_not_in: [String!]
  status_lt: String
  status_lte: String
  status_gt: String
  status_gte: String
  status_contains: String
  status_not_contains: String
  status_starts_with: String
  status_not_starts_with: String
  status_ends_with: String
  status_not_ends_with: String
  ratios_every: RatiosWhereInput
  ratios_some: RatiosWhereInput
  ratios_none: RatiosWhereInput
  AND: [IssuesWhereInput!]
  OR: [IssuesWhereInput!]
  NOT: [IssuesWhereInput!]
}

input IssuesWhereUniqueInput {
  id: ID
}

type Judge {
  id: ID!
  name: String!
  title: String!
  image: String!
  bio: String!
  dob: DateTime
  State: String!
  ctb: String!
  education: String!
  likes: Int
  remark: String!
  cases(where: CasesWhereInput, orderBy: CasesOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Cases!]
}

type JudgeConnection {
  pageInfo: PageInfo!
  edges: [JudgeEdge]!
  aggregate: AggregateJudge!
}

input JudgeCreateInput {
  id: ID
  name: String!
  title: String!
  image: String!
  bio: String!
  dob: DateTime
  State: String!
  ctb: String!
  education: String!
  likes: Int
  remark: String!
  cases: CasesCreateManyWithoutJudgesInput
}

input JudgeCreateManyWithoutCasesInput {
  create: [JudgeCreateWithoutCasesInput!]
  connect: [JudgeWhereUniqueInput!]
}

input JudgeCreateOneInput {
  create: JudgeCreateInput
  connect: JudgeWhereUniqueInput
}

input JudgeCreateWithoutCasesInput {
  id: ID
  name: String!
  title: String!
  image: String!
  bio: String!
  dob: DateTime
  State: String!
  ctb: String!
  education: String!
  likes: Int
  remark: String!
}

type JudgeEdge {
  node: Judge!
  cursor: String!
}

enum JudgeOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  title_ASC
  title_DESC
  image_ASC
  image_DESC
  bio_ASC
  bio_DESC
  dob_ASC
  dob_DESC
  State_ASC
  State_DESC
  ctb_ASC
  ctb_DESC
  education_ASC
  education_DESC
  likes_ASC
  likes_DESC
  remark_ASC
  remark_DESC
}

type JudgePreviousValues {
  id: ID!
  name: String!
  title: String!
  image: String!
  bio: String!
  dob: DateTime
  State: String!
  ctb: String!
  education: String!
  likes: Int
  remark: String!
}

input JudgeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  bio: String
  bio_not: String
  bio_in: [String!]
  bio_not_in: [String!]
  bio_lt: String
  bio_lte: String
  bio_gt: String
  bio_gte: String
  bio_contains: String
  bio_not_contains: String
  bio_starts_with: String
  bio_not_starts_with: String
  bio_ends_with: String
  bio_not_ends_with: String
  dob: DateTime
  dob_not: DateTime
  dob_in: [DateTime!]
  dob_not_in: [DateTime!]
  dob_lt: DateTime
  dob_lte: DateTime
  dob_gt: DateTime
  dob_gte: DateTime
  State: String
  State_not: String
  State_in: [String!]
  State_not_in: [String!]
  State_lt: String
  State_lte: String
  State_gt: String
  State_gte: String
  State_contains: String
  State_not_contains: String
  State_starts_with: String
  State_not_starts_with: String
  State_ends_with: String
  State_not_ends_with: String
  ctb: String
  ctb_not: String
  ctb_in: [String!]
  ctb_not_in: [String!]
  ctb_lt: String
  ctb_lte: String
  ctb_gt: String
  ctb_gte: String
  ctb_contains: String
  ctb_not_contains: String
  ctb_starts_with: String
  ctb_not_starts_with: String
  ctb_ends_with: String
  ctb_not_ends_with: String
  education: String
  education_not: String
  education_in: [String!]
  education_not_in: [String!]
  education_lt: String
  education_lte: String
  education_gt: String
  education_gte: String
  education_contains: String
  education_not_contains: String
  education_starts_with: String
  education_not_starts_with: String
  education_ends_with: String
  education_not_ends_with: String
  likes: Int
  likes_not: Int
  likes_in: [Int!]
  likes_not_in: [Int!]
  likes_lt: Int
  likes_lte: Int
  likes_gt: Int
  likes_gte: Int
  remark: String
  remark_not: String
  remark_in: [String!]
  remark_not_in: [String!]
  remark_lt: String
  remark_lte: String
  remark_gt: String
  remark_gte: String
  remark_contains: String
  remark_not_contains: String
  remark_starts_with: String
  remark_not_starts_with: String
  remark_ends_with: String
  remark_not_ends_with: String
  AND: [JudgeScalarWhereInput!]
  OR: [JudgeScalarWhereInput!]
  NOT: [JudgeScalarWhereInput!]
}

type JudgeSubscriptionPayload {
  mutation: MutationType!
  node: Judge
  updatedFields: [String!]
  previousValues: JudgePreviousValues
}

input JudgeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: JudgeWhereInput
  AND: [JudgeSubscriptionWhereInput!]
  OR: [JudgeSubscriptionWhereInput!]
  NOT: [JudgeSubscriptionWhereInput!]
}

input JudgeUpdateDataInput {
  name: String
  title: String
  image: String
  bio: String
  dob: DateTime
  State: String
  ctb: String
  education: String
  likes: Int
  remark: String
  cases: CasesUpdateManyWithoutJudgesInput
}

input JudgeUpdateInput {
  name: String
  title: String
  image: String
  bio: String
  dob: DateTime
  State: String
  ctb: String
  education: String
  likes: Int
  remark: String
  cases: CasesUpdateManyWithoutJudgesInput
}

input JudgeUpdateManyDataInput {
  name: String
  title: String
  image: String
  bio: String
  dob: DateTime
  State: String
  ctb: String
  education: String
  likes: Int
  remark: String
}

input JudgeUpdateManyMutationInput {
  name: String
  title: String
  image: String
  bio: String
  dob: DateTime
  State: String
  ctb: String
  education: String
  likes: Int
  remark: String
}

input JudgeUpdateManyWithoutCasesInput {
  create: [JudgeCreateWithoutCasesInput!]
  delete: [JudgeWhereUniqueInput!]
  connect: [JudgeWhereUniqueInput!]
  set: [JudgeWhereUniqueInput!]
  disconnect: [JudgeWhereUniqueInput!]
  update: [JudgeUpdateWithWhereUniqueWithoutCasesInput!]
  upsert: [JudgeUpsertWithWhereUniqueWithoutCasesInput!]
  deleteMany: [JudgeScalarWhereInput!]
  updateMany: [JudgeUpdateManyWithWhereNestedInput!]
}

input JudgeUpdateManyWithWhereNestedInput {
  where: JudgeScalarWhereInput!
  data: JudgeUpdateManyDataInput!
}

input JudgeUpdateOneInput {
  create: JudgeCreateInput
  update: JudgeUpdateDataInput
  upsert: JudgeUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: JudgeWhereUniqueInput
}

input JudgeUpdateWithoutCasesDataInput {
  name: String
  title: String
  image: String
  bio: String
  dob: DateTime
  State: String
  ctb: String
  education: String
  likes: Int
  remark: String
}

input JudgeUpdateWithWhereUniqueWithoutCasesInput {
  where: JudgeWhereUniqueInput!
  data: JudgeUpdateWithoutCasesDataInput!
}

input JudgeUpsertNestedInput {
  update: JudgeUpdateDataInput!
  create: JudgeCreateInput!
}

input JudgeUpsertWithWhereUniqueWithoutCasesInput {
  where: JudgeWhereUniqueInput!
  update: JudgeUpdateWithoutCasesDataInput!
  create: JudgeCreateWithoutCasesInput!
}

input JudgeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  bio: String
  bio_not: String
  bio_in: [String!]
  bio_not_in: [String!]
  bio_lt: String
  bio_lte: String
  bio_gt: String
  bio_gte: String
  bio_contains: String
  bio_not_contains: String
  bio_starts_with: String
  bio_not_starts_with: String
  bio_ends_with: String
  bio_not_ends_with: String
  dob: DateTime
  dob_not: DateTime
  dob_in: [DateTime!]
  dob_not_in: [DateTime!]
  dob_lt: DateTime
  dob_lte: DateTime
  dob_gt: DateTime
  dob_gte: DateTime
  State: String
  State_not: String
  State_in: [String!]
  State_not_in: [String!]
  State_lt: String
  State_lte: String
  State_gt: String
  State_gte: String
  State_contains: String
  State_not_contains: String
  State_starts_with: String
  State_not_starts_with: String
  State_ends_with: String
  State_not_ends_with: String
  ctb: String
  ctb_not: String
  ctb_in: [String!]
  ctb_not_in: [String!]
  ctb_lt: String
  ctb_lte: String
  ctb_gt: String
  ctb_gte: String
  ctb_contains: String
  ctb_not_contains: String
  ctb_starts_with: String
  ctb_not_starts_with: String
  ctb_ends_with: String
  ctb_not_ends_with: String
  education: String
  education_not: String
  education_in: [String!]
  education_not_in: [String!]
  education_lt: String
  education_lte: String
  education_gt: String
  education_gte: String
  education_contains: String
  education_not_contains: String
  education_starts_with: String
  education_not_starts_with: String
  education_ends_with: String
  education_not_ends_with: String
  likes: Int
  likes_not: Int
  likes_in: [Int!]
  likes_not_in: [Int!]
  likes_lt: Int
  likes_lte: Int
  likes_gt: Int
  likes_gte: Int
  remark: String
  remark_not: String
  remark_in: [String!]
  remark_not_in: [String!]
  remark_lt: String
  remark_lte: String
  remark_gt: String
  remark_gte: String
  remark_contains: String
  remark_not_contains: String
  remark_starts_with: String
  remark_not_starts_with: String
  remark_ends_with: String
  remark_not_ends_with: String
  cases_every: CasesWhereInput
  cases_some: CasesWhereInput
  cases_none: CasesWhereInput
  AND: [JudgeWhereInput!]
  OR: [JudgeWhereInput!]
  NOT: [JudgeWhereInput!]
}

input JudgeWhereUniqueInput {
  id: ID
}

type Location {
  id: ID!
  town: String
  state: String
}

type LocationConnection {
  pageInfo: PageInfo!
  edges: [LocationEdge]!
  aggregate: AggregateLocation!
}

input LocationCreateInput {
  id: ID
  town: String
  state: String
}

input LocationCreateOneInput {
  create: LocationCreateInput
  connect: LocationWhereUniqueInput
}

type LocationEdge {
  node: Location!
  cursor: String!
}

enum LocationOrderByInput {
  id_ASC
  id_DESC
  town_ASC
  town_DESC
  state_ASC
  state_DESC
}

type LocationPreviousValues {
  id: ID!
  town: String
  state: String
}

type LocationSubscriptionPayload {
  mutation: MutationType!
  node: Location
  updatedFields: [String!]
  previousValues: LocationPreviousValues
}

input LocationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LocationWhereInput
  AND: [LocationSubscriptionWhereInput!]
  OR: [LocationSubscriptionWhereInput!]
  NOT: [LocationSubscriptionWhereInput!]
}

input LocationUpdateDataInput {
  town: String
  state: String
}

input LocationUpdateInput {
  town: String
  state: String
}

input LocationUpdateManyMutationInput {
  town: String
  state: String
}

input LocationUpdateOneInput {
  create: LocationCreateInput
  update: LocationUpdateDataInput
  upsert: LocationUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: LocationWhereUniqueInput
}

input LocationUpsertNestedInput {
  update: LocationUpdateDataInput!
  create: LocationCreateInput!
}

input LocationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  town: String
  town_not: String
  town_in: [String!]
  town_not_in: [String!]
  town_lt: String
  town_lte: String
  town_gt: String
  town_gte: String
  town_contains: String
  town_not_contains: String
  town_starts_with: String
  town_not_starts_with: String
  town_ends_with: String
  town_not_ends_with: String
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  AND: [LocationWhereInput!]
  OR: [LocationWhereInput!]
  NOT: [LocationWhereInput!]
}

input LocationWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createCases(data: CasesCreateInput!): Cases!
  updateCases(data: CasesUpdateInput!, where: CasesWhereUniqueInput!): Cases
  updateManyCaseses(data: CasesUpdateManyMutationInput!, where: CasesWhereInput): BatchPayload!
  upsertCases(where: CasesWhereUniqueInput!, create: CasesCreateInput!, update: CasesUpdateInput!): Cases!
  deleteCases(where: CasesWhereUniqueInput!): Cases
  deleteManyCaseses(where: CasesWhereInput): BatchPayload!
  createCategory(data: CategoryCreateInput!): Category!
  updateCategory(data: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category
  updateManyCategories(data: CategoryUpdateManyMutationInput!, where: CategoryWhereInput): BatchPayload!
  upsertCategory(where: CategoryWhereUniqueInput!, create: CategoryCreateInput!, update: CategoryUpdateInput!): Category!
  deleteCategory(where: CategoryWhereUniqueInput!): Category
  deleteManyCategories(where: CategoryWhereInput): BatchPayload!
  createComment(data: CommentCreateInput!): Comment!
  updateComment(data: CommentUpdateInput!, where: CommentWhereUniqueInput!): Comment
  updateManyComments(data: CommentUpdateManyMutationInput!, where: CommentWhereInput): BatchPayload!
  upsertComment(where: CommentWhereUniqueInput!, create: CommentCreateInput!, update: CommentUpdateInput!): Comment!
  deleteComment(where: CommentWhereUniqueInput!): Comment
  deleteManyComments(where: CommentWhereInput): BatchPayload!
  createContents(data: ContentsCreateInput!): Contents!
  updateContents(data: ContentsUpdateInput!, where: ContentsWhereUniqueInput!): Contents
  updateManyContentses(data: ContentsUpdateManyMutationInput!, where: ContentsWhereInput): BatchPayload!
  upsertContents(where: ContentsWhereUniqueInput!, create: ContentsCreateInput!, update: ContentsUpdateInput!): Contents!
  deleteContents(where: ContentsWhereUniqueInput!): Contents
  deleteManyContentses(where: ContentsWhereInput): BatchPayload!
  createCounsel(data: CounselCreateInput!): Counsel!
  updateCounsel(data: CounselUpdateInput!, where: CounselWhereUniqueInput!): Counsel
  updateManyCounsels(data: CounselUpdateManyMutationInput!, where: CounselWhereInput): BatchPayload!
  upsertCounsel(where: CounselWhereUniqueInput!, create: CounselCreateInput!, update: CounselUpdateInput!): Counsel!
  deleteCounsel(where: CounselWhereUniqueInput!): Counsel
  deleteManyCounsels(where: CounselWhereInput): BatchPayload!
  createFaq(data: FaqCreateInput!): Faq!
  updateFaq(data: FaqUpdateInput!, where: FaqWhereUniqueInput!): Faq
  updateManyFaqs(data: FaqUpdateManyMutationInput!, where: FaqWhereInput): BatchPayload!
  upsertFaq(where: FaqWhereUniqueInput!, create: FaqCreateInput!, update: FaqUpdateInput!): Faq!
  deleteFaq(where: FaqWhereUniqueInput!): Faq
  deleteManyFaqs(where: FaqWhereInput): BatchPayload!
  createIssues(data: IssuesCreateInput!): Issues!
  updateIssues(data: IssuesUpdateInput!, where: IssuesWhereUniqueInput!): Issues
  updateManyIssueses(data: IssuesUpdateManyMutationInput!, where: IssuesWhereInput): BatchPayload!
  upsertIssues(where: IssuesWhereUniqueInput!, create: IssuesCreateInput!, update: IssuesUpdateInput!): Issues!
  deleteIssues(where: IssuesWhereUniqueInput!): Issues
  deleteManyIssueses(where: IssuesWhereInput): BatchPayload!
  createJudge(data: JudgeCreateInput!): Judge!
  updateJudge(data: JudgeUpdateInput!, where: JudgeWhereUniqueInput!): Judge
  updateManyJudges(data: JudgeUpdateManyMutationInput!, where: JudgeWhereInput): BatchPayload!
  upsertJudge(where: JudgeWhereUniqueInput!, create: JudgeCreateInput!, update: JudgeUpdateInput!): Judge!
  deleteJudge(where: JudgeWhereUniqueInput!): Judge
  deleteManyJudges(where: JudgeWhereInput): BatchPayload!
  createLocation(data: LocationCreateInput!): Location!
  updateLocation(data: LocationUpdateInput!, where: LocationWhereUniqueInput!): Location
  updateManyLocations(data: LocationUpdateManyMutationInput!, where: LocationWhereInput): BatchPayload!
  upsertLocation(where: LocationWhereUniqueInput!, create: LocationCreateInput!, update: LocationUpdateInput!): Location!
  deleteLocation(where: LocationWhereUniqueInput!): Location
  deleteManyLocations(where: LocationWhereInput): BatchPayload!
  createPost(data: PostCreateInput!): Post!
  updatePost(data: PostUpdateInput!, where: PostWhereUniqueInput!): Post
  updateManyPosts(data: PostUpdateManyMutationInput!, where: PostWhereInput): BatchPayload!
  upsertPost(where: PostWhereUniqueInput!, create: PostCreateInput!, update: PostUpdateInput!): Post!
  deletePost(where: PostWhereUniqueInput!): Post
  deleteManyPosts(where: PostWhereInput): BatchPayload!
  createQuestion(data: QuestionCreateInput!): Question!
  updateQuestion(data: QuestionUpdateInput!, where: QuestionWhereUniqueInput!): Question
  updateManyQuestions(data: QuestionUpdateManyMutationInput!, where: QuestionWhereInput): BatchPayload!
  upsertQuestion(where: QuestionWhereUniqueInput!, create: QuestionCreateInput!, update: QuestionUpdateInput!): Question!
  deleteQuestion(where: QuestionWhereUniqueInput!): Question
  deleteManyQuestions(where: QuestionWhereInput): BatchPayload!
  createRatios(data: RatiosCreateInput!): Ratios!
  updateRatios(data: RatiosUpdateInput!, where: RatiosWhereUniqueInput!): Ratios
  updateManyRatioses(data: RatiosUpdateManyMutationInput!, where: RatiosWhereInput): BatchPayload!
  upsertRatios(where: RatiosWhereUniqueInput!, create: RatiosCreateInput!, update: RatiosUpdateInput!): Ratios!
  deleteRatios(where: RatiosWhereUniqueInput!): Ratios
  deleteManyRatioses(where: RatiosWhereInput): BatchPayload!
  createReport(data: ReportCreateInput!): Report!
  updateReport(data: ReportUpdateInput!, where: ReportWhereUniqueInput!): Report
  updateManyReports(data: ReportUpdateManyMutationInput!, where: ReportWhereInput): BatchPayload!
  upsertReport(where: ReportWhereUniqueInput!, create: ReportCreateInput!, update: ReportUpdateInput!): Report!
  deleteReport(where: ReportWhereUniqueInput!): Report
  deleteManyReports(where: ReportWhereInput): BatchPayload!
  createSub(data: SubCreateInput!): Sub!
  updateSub(data: SubUpdateInput!, where: SubWhereUniqueInput!): Sub
  updateManySubs(data: SubUpdateManyMutationInput!, where: SubWhereInput): BatchPayload!
  upsertSub(where: SubWhereUniqueInput!, create: SubCreateInput!, update: SubUpdateInput!): Sub!
  deleteSub(where: SubWhereUniqueInput!): Sub
  deleteManySubs(where: SubWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createVol(data: VolCreateInput!): Vol!
  updateVol(data: VolUpdateInput!, where: VolWhereUniqueInput!): Vol
  updateManyVols(data: VolUpdateManyMutationInput!, where: VolWhereInput): BatchPayload!
  upsertVol(where: VolWhereUniqueInput!, create: VolCreateInput!, update: VolUpdateInput!): Vol!
  deleteVol(where: VolWhereUniqueInput!): Vol
  deleteManyVols(where: VolWhereInput): BatchPayload!
  createisActive(data: isActiveCreateInput!): isActive!
  updateisActive(data: isActiveUpdateInput!, where: isActiveWhereUniqueInput!): isActive
  updateManyisActives(data: isActiveUpdateManyMutationInput!, where: isActiveWhereInput): BatchPayload!
  upsertisActive(where: isActiveWhereUniqueInput!, create: isActiveCreateInput!, update: isActiveUpdateInput!): isActive!
  deleteisActive(where: isActiveWhereUniqueInput!): isActive
  deleteManyisActives(where: isActiveWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Post {
  id: ID!
  title: String
  category: String
  body: String
  image: String
  desc: String
  createdAt: DateTime
  author: User!
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment!]
}

type PostConnection {
  pageInfo: PageInfo!
  edges: [PostEdge]!
  aggregate: AggregatePost!
}

input PostCreateInput {
  id: ID
  title: String
  category: String
  body: String
  image: String
  desc: String
  author: UserCreateOneWithoutPostInput!
  comments: CommentCreateManyInput
}

input PostCreateManyWithoutAuthorInput {
  create: [PostCreateWithoutAuthorInput!]
  connect: [PostWhereUniqueInput!]
}

input PostCreateWithoutAuthorInput {
  id: ID
  title: String
  category: String
  body: String
  image: String
  desc: String
  comments: CommentCreateManyInput
}

type PostEdge {
  node: Post!
  cursor: String!
}

enum PostOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  category_ASC
  category_DESC
  body_ASC
  body_DESC
  image_ASC
  image_DESC
  desc_ASC
  desc_DESC
  createdAt_ASC
  createdAt_DESC
}

type PostPreviousValues {
  id: ID!
  title: String
  category: String
  body: String
  image: String
  desc: String
  createdAt: DateTime
}

input PostScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  category: String
  category_not: String
  category_in: [String!]
  category_not_in: [String!]
  category_lt: String
  category_lte: String
  category_gt: String
  category_gte: String
  category_contains: String
  category_not_contains: String
  category_starts_with: String
  category_not_starts_with: String
  category_ends_with: String
  category_not_ends_with: String
  body: String
  body_not: String
  body_in: [String!]
  body_not_in: [String!]
  body_lt: String
  body_lte: String
  body_gt: String
  body_gte: String
  body_contains: String
  body_not_contains: String
  body_starts_with: String
  body_not_starts_with: String
  body_ends_with: String
  body_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  desc: String
  desc_not: String
  desc_in: [String!]
  desc_not_in: [String!]
  desc_lt: String
  desc_lte: String
  desc_gt: String
  desc_gte: String
  desc_contains: String
  desc_not_contains: String
  desc_starts_with: String
  desc_not_starts_with: String
  desc_ends_with: String
  desc_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [PostScalarWhereInput!]
  OR: [PostScalarWhereInput!]
  NOT: [PostScalarWhereInput!]
}

type PostSubscriptionPayload {
  mutation: MutationType!
  node: Post
  updatedFields: [String!]
  previousValues: PostPreviousValues
}

input PostSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PostWhereInput
  AND: [PostSubscriptionWhereInput!]
  OR: [PostSubscriptionWhereInput!]
  NOT: [PostSubscriptionWhereInput!]
}

input PostUpdateInput {
  title: String
  category: String
  body: String
  image: String
  desc: String
  author: UserUpdateOneRequiredWithoutPostInput
  comments: CommentUpdateManyInput
}

input PostUpdateManyDataInput {
  title: String
  category: String
  body: String
  image: String
  desc: String
}

input PostUpdateManyMutationInput {
  title: String
  category: String
  body: String
  image: String
  desc: String
}

input PostUpdateManyWithoutAuthorInput {
  create: [PostCreateWithoutAuthorInput!]
  delete: [PostWhereUniqueInput!]
  connect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  disconnect: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutAuthorInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutAuthorInput!]
  deleteMany: [PostScalarWhereInput!]
  updateMany: [PostUpdateManyWithWhereNestedInput!]
}

input PostUpdateManyWithWhereNestedInput {
  where: PostScalarWhereInput!
  data: PostUpdateManyDataInput!
}

input PostUpdateWithoutAuthorDataInput {
  title: String
  category: String
  body: String
  image: String
  desc: String
  comments: CommentUpdateManyInput
}

input PostUpdateWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput!
  data: PostUpdateWithoutAuthorDataInput!
}

input PostUpsertWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput!
  update: PostUpdateWithoutAuthorDataInput!
  create: PostCreateWithoutAuthorInput!
}

input PostWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  category: String
  category_not: String
  category_in: [String!]
  category_not_in: [String!]
  category_lt: String
  category_lte: String
  category_gt: String
  category_gte: String
  category_contains: String
  category_not_contains: String
  category_starts_with: String
  category_not_starts_with: String
  category_ends_with: String
  category_not_ends_with: String
  body: String
  body_not: String
  body_in: [String!]
  body_not_in: [String!]
  body_lt: String
  body_lte: String
  body_gt: String
  body_gte: String
  body_contains: String
  body_not_contains: String
  body_starts_with: String
  body_not_starts_with: String
  body_ends_with: String
  body_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  desc: String
  desc_not: String
  desc_in: [String!]
  desc_not_in: [String!]
  desc_lt: String
  desc_lte: String
  desc_gt: String
  desc_gte: String
  desc_contains: String
  desc_not_contains: String
  desc_starts_with: String
  desc_not_starts_with: String
  desc_ends_with: String
  desc_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  author: UserWhereInput
  comments_every: CommentWhereInput
  comments_some: CommentWhereInput
  comments_none: CommentWhereInput
  AND: [PostWhereInput!]
  OR: [PostWhereInput!]
  NOT: [PostWhereInput!]
}

input PostWhereUniqueInput {
  id: ID
}

type Query {
  cases(where: CasesWhereUniqueInput!): Cases
  caseses(where: CasesWhereInput, orderBy: CasesOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Cases]!
  casesesConnection(where: CasesWhereInput, orderBy: CasesOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CasesConnection!
  category(where: CategoryWhereUniqueInput!): Category
  categories(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Category]!
  categoriesConnection(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CategoryConnection!
  comment(where: CommentWhereUniqueInput!): Comment
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment]!
  commentsConnection(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CommentConnection!
  contents(where: ContentsWhereUniqueInput!): Contents
  contentses(where: ContentsWhereInput, orderBy: ContentsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Contents]!
  contentsesConnection(where: ContentsWhereInput, orderBy: ContentsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ContentsConnection!
  counsel(where: CounselWhereUniqueInput!): Counsel
  counsels(where: CounselWhereInput, orderBy: CounselOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Counsel]!
  counselsConnection(where: CounselWhereInput, orderBy: CounselOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CounselConnection!
  faq(where: FaqWhereUniqueInput!): Faq
  faqs(where: FaqWhereInput, orderBy: FaqOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Faq]!
  faqsConnection(where: FaqWhereInput, orderBy: FaqOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FaqConnection!
  issues(where: IssuesWhereUniqueInput!): Issues
  issueses(where: IssuesWhereInput, orderBy: IssuesOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Issues]!
  issuesesConnection(where: IssuesWhereInput, orderBy: IssuesOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): IssuesConnection!
  judge(where: JudgeWhereUniqueInput!): Judge
  judges(where: JudgeWhereInput, orderBy: JudgeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Judge]!
  judgesConnection(where: JudgeWhereInput, orderBy: JudgeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): JudgeConnection!
  location(where: LocationWhereUniqueInput!): Location
  locations(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Location]!
  locationsConnection(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LocationConnection!
  post(where: PostWhereUniqueInput!): Post
  posts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post]!
  postsConnection(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PostConnection!
  question(where: QuestionWhereUniqueInput!): Question
  questions(where: QuestionWhereInput, orderBy: QuestionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Question]!
  questionsConnection(where: QuestionWhereInput, orderBy: QuestionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): QuestionConnection!
  ratios(where: RatiosWhereUniqueInput!): Ratios
  ratioses(where: RatiosWhereInput, orderBy: RatiosOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Ratios]!
  ratiosesConnection(where: RatiosWhereInput, orderBy: RatiosOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RatiosConnection!
  report(where: ReportWhereUniqueInput!): Report
  reports(where: ReportWhereInput, orderBy: ReportOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Report]!
  reportsConnection(where: ReportWhereInput, orderBy: ReportOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ReportConnection!
  sub(where: SubWhereUniqueInput!): Sub
  subs(where: SubWhereInput, orderBy: SubOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Sub]!
  subsConnection(where: SubWhereInput, orderBy: SubOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SubConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  vol(where: VolWhereUniqueInput!): Vol
  vols(where: VolWhereInput, orderBy: VolOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Vol]!
  volsConnection(where: VolWhereInput, orderBy: VolOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): VolConnection!
  isActive(where: isActiveWhereUniqueInput!): isActive
  isActives(where: isActiveWhereInput, orderBy: isActiveOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [isActive]!
  isActivesConnection(where: isActiveWhereInput, orderBy: isActiveOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): isActiveConnection!
  node(id: ID!): Node
}

type Question {
  id: ID!
  qns: String!
  ans: String!
}

type QuestionConnection {
  pageInfo: PageInfo!
  edges: [QuestionEdge]!
  aggregate: AggregateQuestion!
}

input QuestionCreateInput {
  id: ID
  qns: String!
  ans: String!
}

input QuestionCreateManyInput {
  create: [QuestionCreateInput!]
  connect: [QuestionWhereUniqueInput!]
}

type QuestionEdge {
  node: Question!
  cursor: String!
}

enum QuestionOrderByInput {
  id_ASC
  id_DESC
  qns_ASC
  qns_DESC
  ans_ASC
  ans_DESC
}

type QuestionPreviousValues {
  id: ID!
  qns: String!
  ans: String!
}

input QuestionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  qns: String
  qns_not: String
  qns_in: [String!]
  qns_not_in: [String!]
  qns_lt: String
  qns_lte: String
  qns_gt: String
  qns_gte: String
  qns_contains: String
  qns_not_contains: String
  qns_starts_with: String
  qns_not_starts_with: String
  qns_ends_with: String
  qns_not_ends_with: String
  ans: String
  ans_not: String
  ans_in: [String!]
  ans_not_in: [String!]
  ans_lt: String
  ans_lte: String
  ans_gt: String
  ans_gte: String
  ans_contains: String
  ans_not_contains: String
  ans_starts_with: String
  ans_not_starts_with: String
  ans_ends_with: String
  ans_not_ends_with: String
  AND: [QuestionScalarWhereInput!]
  OR: [QuestionScalarWhereInput!]
  NOT: [QuestionScalarWhereInput!]
}

type QuestionSubscriptionPayload {
  mutation: MutationType!
  node: Question
  updatedFields: [String!]
  previousValues: QuestionPreviousValues
}

input QuestionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: QuestionWhereInput
  AND: [QuestionSubscriptionWhereInput!]
  OR: [QuestionSubscriptionWhereInput!]
  NOT: [QuestionSubscriptionWhereInput!]
}

input QuestionUpdateDataInput {
  qns: String
  ans: String
}

input QuestionUpdateInput {
  qns: String
  ans: String
}

input QuestionUpdateManyDataInput {
  qns: String
  ans: String
}

input QuestionUpdateManyInput {
  create: [QuestionCreateInput!]
  update: [QuestionUpdateWithWhereUniqueNestedInput!]
  upsert: [QuestionUpsertWithWhereUniqueNestedInput!]
  delete: [QuestionWhereUniqueInput!]
  connect: [QuestionWhereUniqueInput!]
  set: [QuestionWhereUniqueInput!]
  disconnect: [QuestionWhereUniqueInput!]
  deleteMany: [QuestionScalarWhereInput!]
  updateMany: [QuestionUpdateManyWithWhereNestedInput!]
}

input QuestionUpdateManyMutationInput {
  qns: String
  ans: String
}

input QuestionUpdateManyWithWhereNestedInput {
  where: QuestionScalarWhereInput!
  data: QuestionUpdateManyDataInput!
}

input QuestionUpdateWithWhereUniqueNestedInput {
  where: QuestionWhereUniqueInput!
  data: QuestionUpdateDataInput!
}

input QuestionUpsertWithWhereUniqueNestedInput {
  where: QuestionWhereUniqueInput!
  update: QuestionUpdateDataInput!
  create: QuestionCreateInput!
}

input QuestionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  qns: String
  qns_not: String
  qns_in: [String!]
  qns_not_in: [String!]
  qns_lt: String
  qns_lte: String
  qns_gt: String
  qns_gte: String
  qns_contains: String
  qns_not_contains: String
  qns_starts_with: String
  qns_not_starts_with: String
  qns_ends_with: String
  qns_not_ends_with: String
  ans: String
  ans_not: String
  ans_in: [String!]
  ans_not_in: [String!]
  ans_lt: String
  ans_lte: String
  ans_gt: String
  ans_gte: String
  ans_contains: String
  ans_not_contains: String
  ans_starts_with: String
  ans_not_starts_with: String
  ans_ends_with: String
  ans_not_ends_with: String
  AND: [QuestionWhereInput!]
  OR: [QuestionWhereInput!]
  NOT: [QuestionWhereInput!]
}

input QuestionWhereUniqueInput {
  id: ID
}

type Ratios {
  id: ID!
  heading: String
  contents: Contents
}

type RatiosConnection {
  pageInfo: PageInfo!
  edges: [RatiosEdge]!
  aggregate: AggregateRatios!
}

input RatiosCreateInput {
  id: ID
  heading: String
  contents: ContentsCreateOneInput
}

input RatiosCreateManyInput {
  create: [RatiosCreateInput!]
  connect: [RatiosWhereUniqueInput!]
}

type RatiosEdge {
  node: Ratios!
  cursor: String!
}

enum RatiosOrderByInput {
  id_ASC
  id_DESC
  heading_ASC
  heading_DESC
}

type RatiosPreviousValues {
  id: ID!
  heading: String
}

input RatiosScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  heading: String
  heading_not: String
  heading_in: [String!]
  heading_not_in: [String!]
  heading_lt: String
  heading_lte: String
  heading_gt: String
  heading_gte: String
  heading_contains: String
  heading_not_contains: String
  heading_starts_with: String
  heading_not_starts_with: String
  heading_ends_with: String
  heading_not_ends_with: String
  AND: [RatiosScalarWhereInput!]
  OR: [RatiosScalarWhereInput!]
  NOT: [RatiosScalarWhereInput!]
}

type RatiosSubscriptionPayload {
  mutation: MutationType!
  node: Ratios
  updatedFields: [String!]
  previousValues: RatiosPreviousValues
}

input RatiosSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RatiosWhereInput
  AND: [RatiosSubscriptionWhereInput!]
  OR: [RatiosSubscriptionWhereInput!]
  NOT: [RatiosSubscriptionWhereInput!]
}

input RatiosUpdateDataInput {
  heading: String
  contents: ContentsUpdateOneInput
}

input RatiosUpdateInput {
  heading: String
  contents: ContentsUpdateOneInput
}

input RatiosUpdateManyDataInput {
  heading: String
}

input RatiosUpdateManyInput {
  create: [RatiosCreateInput!]
  update: [RatiosUpdateWithWhereUniqueNestedInput!]
  upsert: [RatiosUpsertWithWhereUniqueNestedInput!]
  delete: [RatiosWhereUniqueInput!]
  connect: [RatiosWhereUniqueInput!]
  set: [RatiosWhereUniqueInput!]
  disconnect: [RatiosWhereUniqueInput!]
  deleteMany: [RatiosScalarWhereInput!]
  updateMany: [RatiosUpdateManyWithWhereNestedInput!]
}

input RatiosUpdateManyMutationInput {
  heading: String
}

input RatiosUpdateManyWithWhereNestedInput {
  where: RatiosScalarWhereInput!
  data: RatiosUpdateManyDataInput!
}

input RatiosUpdateWithWhereUniqueNestedInput {
  where: RatiosWhereUniqueInput!
  data: RatiosUpdateDataInput!
}

input RatiosUpsertWithWhereUniqueNestedInput {
  where: RatiosWhereUniqueInput!
  update: RatiosUpdateDataInput!
  create: RatiosCreateInput!
}

input RatiosWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  heading: String
  heading_not: String
  heading_in: [String!]
  heading_not_in: [String!]
  heading_lt: String
  heading_lte: String
  heading_gt: String
  heading_gte: String
  heading_contains: String
  heading_not_contains: String
  heading_starts_with: String
  heading_not_starts_with: String
  heading_ends_with: String
  heading_not_ends_with: String
  contents: ContentsWhereInput
  AND: [RatiosWhereInput!]
  OR: [RatiosWhereInput!]
  NOT: [RatiosWhereInput!]
}

input RatiosWhereUniqueInput {
  id: ID
}

type Report {
  id: ID!
  vols(where: VolWhereInput, orderBy: VolOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Vol!]
  year: Int
}

type ReportConnection {
  pageInfo: PageInfo!
  edges: [ReportEdge]!
  aggregate: AggregateReport!
}

input ReportCreateInput {
  id: ID
  vols: VolCreateManyWithoutReportInput
  year: Int
}

input ReportCreateOneWithoutVolsInput {
  create: ReportCreateWithoutVolsInput
  connect: ReportWhereUniqueInput
}

input ReportCreateWithoutVolsInput {
  id: ID
  year: Int
}

type ReportEdge {
  node: Report!
  cursor: String!
}

enum ReportOrderByInput {
  id_ASC
  id_DESC
  year_ASC
  year_DESC
}

type ReportPreviousValues {
  id: ID!
  year: Int
}

type ReportSubscriptionPayload {
  mutation: MutationType!
  node: Report
  updatedFields: [String!]
  previousValues: ReportPreviousValues
}

input ReportSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ReportWhereInput
  AND: [ReportSubscriptionWhereInput!]
  OR: [ReportSubscriptionWhereInput!]
  NOT: [ReportSubscriptionWhereInput!]
}

input ReportUpdateInput {
  vols: VolUpdateManyWithoutReportInput
  year: Int
}

input ReportUpdateManyMutationInput {
  year: Int
}

input ReportUpdateOneWithoutVolsInput {
  create: ReportCreateWithoutVolsInput
  update: ReportUpdateWithoutVolsDataInput
  upsert: ReportUpsertWithoutVolsInput
  delete: Boolean
  disconnect: Boolean
  connect: ReportWhereUniqueInput
}

input ReportUpdateWithoutVolsDataInput {
  year: Int
}

input ReportUpsertWithoutVolsInput {
  update: ReportUpdateWithoutVolsDataInput!
  create: ReportCreateWithoutVolsInput!
}

input ReportWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  vols_every: VolWhereInput
  vols_some: VolWhereInput
  vols_none: VolWhereInput
  year: Int
  year_not: Int
  year_in: [Int!]
  year_not_in: [Int!]
  year_lt: Int
  year_lte: Int
  year_gt: Int
  year_gte: Int
  AND: [ReportWhereInput!]
  OR: [ReportWhereInput!]
  NOT: [ReportWhereInput!]
}

input ReportWhereUniqueInput {
  id: ID
}

type Sub {
  id: ID!
  plan: String
  days: Int
  startedIn: DateTime
  expiresIn: DateTime
  isActive: Boolean
}

type SubConnection {
  pageInfo: PageInfo!
  edges: [SubEdge]!
  aggregate: AggregateSub!
}

input SubCreateInput {
  id: ID
  plan: String
  days: Int
  startedIn: DateTime
  expiresIn: DateTime
  isActive: Boolean
}

input SubCreateOneInput {
  create: SubCreateInput
  connect: SubWhereUniqueInput
}

type SubEdge {
  node: Sub!
  cursor: String!
}

enum SubOrderByInput {
  id_ASC
  id_DESC
  plan_ASC
  plan_DESC
  days_ASC
  days_DESC
  startedIn_ASC
  startedIn_DESC
  expiresIn_ASC
  expiresIn_DESC
  isActive_ASC
  isActive_DESC
}

type SubPreviousValues {
  id: ID!
  plan: String
  days: Int
  startedIn: DateTime
  expiresIn: DateTime
  isActive: Boolean
}

type Subscription {
  cases(where: CasesSubscriptionWhereInput): CasesSubscriptionPayload
  category(where: CategorySubscriptionWhereInput): CategorySubscriptionPayload
  comment(where: CommentSubscriptionWhereInput): CommentSubscriptionPayload
  contents(where: ContentsSubscriptionWhereInput): ContentsSubscriptionPayload
  counsel(where: CounselSubscriptionWhereInput): CounselSubscriptionPayload
  faq(where: FaqSubscriptionWhereInput): FaqSubscriptionPayload
  issues(where: IssuesSubscriptionWhereInput): IssuesSubscriptionPayload
  judge(where: JudgeSubscriptionWhereInput): JudgeSubscriptionPayload
  location(where: LocationSubscriptionWhereInput): LocationSubscriptionPayload
  post(where: PostSubscriptionWhereInput): PostSubscriptionPayload
  question(where: QuestionSubscriptionWhereInput): QuestionSubscriptionPayload
  ratios(where: RatiosSubscriptionWhereInput): RatiosSubscriptionPayload
  report(where: ReportSubscriptionWhereInput): ReportSubscriptionPayload
  sub(where: SubSubscriptionWhereInput): SubSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  vol(where: VolSubscriptionWhereInput): VolSubscriptionPayload
  isActive(where: isActiveSubscriptionWhereInput): isActiveSubscriptionPayload
}

type SubSubscriptionPayload {
  mutation: MutationType!
  node: Sub
  updatedFields: [String!]
  previousValues: SubPreviousValues
}

input SubSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SubWhereInput
  AND: [SubSubscriptionWhereInput!]
  OR: [SubSubscriptionWhereInput!]
  NOT: [SubSubscriptionWhereInput!]
}

input SubUpdateDataInput {
  plan: String
  days: Int
  startedIn: DateTime
  expiresIn: DateTime
  isActive: Boolean
}

input SubUpdateInput {
  plan: String
  days: Int
  startedIn: DateTime
  expiresIn: DateTime
  isActive: Boolean
}

input SubUpdateManyMutationInput {
  plan: String
  days: Int
  startedIn: DateTime
  expiresIn: DateTime
  isActive: Boolean
}

input SubUpdateOneInput {
  create: SubCreateInput
  update: SubUpdateDataInput
  upsert: SubUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: SubWhereUniqueInput
}

input SubUpsertNestedInput {
  update: SubUpdateDataInput!
  create: SubCreateInput!
}

input SubWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  plan: String
  plan_not: String
  plan_in: [String!]
  plan_not_in: [String!]
  plan_lt: String
  plan_lte: String
  plan_gt: String
  plan_gte: String
  plan_contains: String
  plan_not_contains: String
  plan_starts_with: String
  plan_not_starts_with: String
  plan_ends_with: String
  plan_not_ends_with: String
  days: Int
  days_not: Int
  days_in: [Int!]
  days_not_in: [Int!]
  days_lt: Int
  days_lte: Int
  days_gt: Int
  days_gte: Int
  startedIn: DateTime
  startedIn_not: DateTime
  startedIn_in: [DateTime!]
  startedIn_not_in: [DateTime!]
  startedIn_lt: DateTime
  startedIn_lte: DateTime
  startedIn_gt: DateTime
  startedIn_gte: DateTime
  expiresIn: DateTime
  expiresIn_not: DateTime
  expiresIn_in: [DateTime!]
  expiresIn_not_in: [DateTime!]
  expiresIn_lt: DateTime
  expiresIn_lte: DateTime
  expiresIn_gt: DateTime
  expiresIn_gte: DateTime
  isActive: Boolean
  isActive_not: Boolean
  AND: [SubWhereInput!]
  OR: [SubWhereInput!]
  NOT: [SubWhereInput!]
}

input SubWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  name: String
  image: String
  username: String
  password: String!
  firstName: String!
  lastName: String!
  phone: String
  email: String!
  about: String
  location: Location
  company: String
  tac: Boolean
  subscription: Sub
  resetPasswordToken: String
  resetPasswordExpires: DateTime
  isAdmin: Boolean
  emailConfirmationToken: String
  isActive: isActive
  joinedDate: DateTime
  post(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  name: String
  image: String
  username: String
  password: String!
  firstName: String!
  lastName: String!
  phone: String
  email: String!
  about: String
  location: LocationCreateOneInput
  company: String
  tac: Boolean
  subscription: SubCreateOneInput
  resetPasswordToken: String
  resetPasswordExpires: DateTime
  isAdmin: Boolean
  emailConfirmationToken: String
  isActive: isActiveCreateOneInput
  joinedDate: DateTime
  post: PostCreateManyWithoutAuthorInput
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutPostInput {
  create: UserCreateWithoutPostInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutPostInput {
  id: ID
  name: String
  image: String
  username: String
  password: String!
  firstName: String!
  lastName: String!
  phone: String
  email: String!
  about: String
  location: LocationCreateOneInput
  company: String
  tac: Boolean
  subscription: SubCreateOneInput
  resetPasswordToken: String
  resetPasswordExpires: DateTime
  isAdmin: Boolean
  emailConfirmationToken: String
  isActive: isActiveCreateOneInput
  joinedDate: DateTime
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  image_ASC
  image_DESC
  username_ASC
  username_DESC
  password_ASC
  password_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  phone_ASC
  phone_DESC
  email_ASC
  email_DESC
  about_ASC
  about_DESC
  company_ASC
  company_DESC
  tac_ASC
  tac_DESC
  resetPasswordToken_ASC
  resetPasswordToken_DESC
  resetPasswordExpires_ASC
  resetPasswordExpires_DESC
  isAdmin_ASC
  isAdmin_DESC
  emailConfirmationToken_ASC
  emailConfirmationToken_DESC
  joinedDate_ASC
  joinedDate_DESC
}

type UserPreviousValues {
  id: ID!
  name: String
  image: String
  username: String
  password: String!
  firstName: String!
  lastName: String!
  phone: String
  email: String!
  about: String
  company: String
  tac: Boolean
  resetPasswordToken: String
  resetPasswordExpires: DateTime
  isAdmin: Boolean
  emailConfirmationToken: String
  joinedDate: DateTime
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  name: String
  image: String
  username: String
  password: String
  firstName: String
  lastName: String
  phone: String
  email: String
  about: String
  location: LocationUpdateOneInput
  company: String
  tac: Boolean
  subscription: SubUpdateOneInput
  resetPasswordToken: String
  resetPasswordExpires: DateTime
  isAdmin: Boolean
  emailConfirmationToken: String
  isActive: isActiveUpdateOneInput
  joinedDate: DateTime
  post: PostUpdateManyWithoutAuthorInput
}

input UserUpdateInput {
  name: String
  image: String
  username: String
  password: String
  firstName: String
  lastName: String
  phone: String
  email: String
  about: String
  location: LocationUpdateOneInput
  company: String
  tac: Boolean
  subscription: SubUpdateOneInput
  resetPasswordToken: String
  resetPasswordExpires: DateTime
  isAdmin: Boolean
  emailConfirmationToken: String
  isActive: isActiveUpdateOneInput
  joinedDate: DateTime
  post: PostUpdateManyWithoutAuthorInput
}

input UserUpdateManyMutationInput {
  name: String
  image: String
  username: String
  password: String
  firstName: String
  lastName: String
  phone: String
  email: String
  about: String
  company: String
  tac: Boolean
  resetPasswordToken: String
  resetPasswordExpires: DateTime
  isAdmin: Boolean
  emailConfirmationToken: String
  joinedDate: DateTime
}

input UserUpdateOneInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutPostInput {
  create: UserCreateWithoutPostInput
  update: UserUpdateWithoutPostDataInput
  upsert: UserUpsertWithoutPostInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutPostDataInput {
  name: String
  image: String
  username: String
  password: String
  firstName: String
  lastName: String
  phone: String
  email: String
  about: String
  location: LocationUpdateOneInput
  company: String
  tac: Boolean
  subscription: SubUpdateOneInput
  resetPasswordToken: String
  resetPasswordExpires: DateTime
  isAdmin: Boolean
  emailConfirmationToken: String
  isActive: isActiveUpdateOneInput
  joinedDate: DateTime
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutPostInput {
  update: UserUpdateWithoutPostDataInput!
  create: UserCreateWithoutPostInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  about: String
  about_not: String
  about_in: [String!]
  about_not_in: [String!]
  about_lt: String
  about_lte: String
  about_gt: String
  about_gte: String
  about_contains: String
  about_not_contains: String
  about_starts_with: String
  about_not_starts_with: String
  about_ends_with: String
  about_not_ends_with: String
  location: LocationWhereInput
  company: String
  company_not: String
  company_in: [String!]
  company_not_in: [String!]
  company_lt: String
  company_lte: String
  company_gt: String
  company_gte: String
  company_contains: String
  company_not_contains: String
  company_starts_with: String
  company_not_starts_with: String
  company_ends_with: String
  company_not_ends_with: String
  tac: Boolean
  tac_not: Boolean
  subscription: SubWhereInput
  resetPasswordToken: String
  resetPasswordToken_not: String
  resetPasswordToken_in: [String!]
  resetPasswordToken_not_in: [String!]
  resetPasswordToken_lt: String
  resetPasswordToken_lte: String
  resetPasswordToken_gt: String
  resetPasswordToken_gte: String
  resetPasswordToken_contains: String
  resetPasswordToken_not_contains: String
  resetPasswordToken_starts_with: String
  resetPasswordToken_not_starts_with: String
  resetPasswordToken_ends_with: String
  resetPasswordToken_not_ends_with: String
  resetPasswordExpires: DateTime
  resetPasswordExpires_not: DateTime
  resetPasswordExpires_in: [DateTime!]
  resetPasswordExpires_not_in: [DateTime!]
  resetPasswordExpires_lt: DateTime
  resetPasswordExpires_lte: DateTime
  resetPasswordExpires_gt: DateTime
  resetPasswordExpires_gte: DateTime
  isAdmin: Boolean
  isAdmin_not: Boolean
  emailConfirmationToken: String
  emailConfirmationToken_not: String
  emailConfirmationToken_in: [String!]
  emailConfirmationToken_not_in: [String!]
  emailConfirmationToken_lt: String
  emailConfirmationToken_lte: String
  emailConfirmationToken_gt: String
  emailConfirmationToken_gte: String
  emailConfirmationToken_contains: String
  emailConfirmationToken_not_contains: String
  emailConfirmationToken_starts_with: String
  emailConfirmationToken_not_starts_with: String
  emailConfirmationToken_ends_with: String
  emailConfirmationToken_not_ends_with: String
  isActive: isActiveWhereInput
  joinedDate: DateTime
  joinedDate_not: DateTime
  joinedDate_in: [DateTime!]
  joinedDate_not_in: [DateTime!]
  joinedDate_lt: DateTime
  joinedDate_lte: DateTime
  joinedDate_gt: DateTime
  joinedDate_gte: DateTime
  post_every: PostWhereInput
  post_some: PostWhereInput
  post_none: PostWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}

type Vol {
  id: ID!
  part_no: Int!
  cases(where: CasesWhereInput, orderBy: CasesOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Cases!]
  year: Int!
  report: Report
}

type VolConnection {
  pageInfo: PageInfo!
  edges: [VolEdge]!
  aggregate: AggregateVol!
}

input VolCreateInput {
  id: ID
  part_no: Int!
  cases: CasesCreateManyWithoutVolInput
  year: Int!
  report: ReportCreateOneWithoutVolsInput
}

input VolCreateManyWithoutReportInput {
  create: [VolCreateWithoutReportInput!]
  connect: [VolWhereUniqueInput!]
}

input VolCreateOneWithoutCasesInput {
  create: VolCreateWithoutCasesInput
  connect: VolWhereUniqueInput
}

input VolCreateWithoutCasesInput {
  id: ID
  part_no: Int!
  year: Int!
  report: ReportCreateOneWithoutVolsInput
}

input VolCreateWithoutReportInput {
  id: ID
  part_no: Int!
  cases: CasesCreateManyWithoutVolInput
  year: Int!
}

type VolEdge {
  node: Vol!
  cursor: String!
}

enum VolOrderByInput {
  id_ASC
  id_DESC
  part_no_ASC
  part_no_DESC
  year_ASC
  year_DESC
}

type VolPreviousValues {
  id: ID!
  part_no: Int!
  year: Int!
}

input VolScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  part_no: Int
  part_no_not: Int
  part_no_in: [Int!]
  part_no_not_in: [Int!]
  part_no_lt: Int
  part_no_lte: Int
  part_no_gt: Int
  part_no_gte: Int
  year: Int
  year_not: Int
  year_in: [Int!]
  year_not_in: [Int!]
  year_lt: Int
  year_lte: Int
  year_gt: Int
  year_gte: Int
  AND: [VolScalarWhereInput!]
  OR: [VolScalarWhereInput!]
  NOT: [VolScalarWhereInput!]
}

type VolSubscriptionPayload {
  mutation: MutationType!
  node: Vol
  updatedFields: [String!]
  previousValues: VolPreviousValues
}

input VolSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: VolWhereInput
  AND: [VolSubscriptionWhereInput!]
  OR: [VolSubscriptionWhereInput!]
  NOT: [VolSubscriptionWhereInput!]
}

input VolUpdateInput {
  part_no: Int
  cases: CasesUpdateManyWithoutVolInput
  year: Int
  report: ReportUpdateOneWithoutVolsInput
}

input VolUpdateManyDataInput {
  part_no: Int
  year: Int
}

input VolUpdateManyMutationInput {
  part_no: Int
  year: Int
}

input VolUpdateManyWithoutReportInput {
  create: [VolCreateWithoutReportInput!]
  delete: [VolWhereUniqueInput!]
  connect: [VolWhereUniqueInput!]
  set: [VolWhereUniqueInput!]
  disconnect: [VolWhereUniqueInput!]
  update: [VolUpdateWithWhereUniqueWithoutReportInput!]
  upsert: [VolUpsertWithWhereUniqueWithoutReportInput!]
  deleteMany: [VolScalarWhereInput!]
  updateMany: [VolUpdateManyWithWhereNestedInput!]
}

input VolUpdateManyWithWhereNestedInput {
  where: VolScalarWhereInput!
  data: VolUpdateManyDataInput!
}

input VolUpdateOneRequiredWithoutCasesInput {
  create: VolCreateWithoutCasesInput
  update: VolUpdateWithoutCasesDataInput
  upsert: VolUpsertWithoutCasesInput
  connect: VolWhereUniqueInput
}

input VolUpdateWithoutCasesDataInput {
  part_no: Int
  year: Int
  report: ReportUpdateOneWithoutVolsInput
}

input VolUpdateWithoutReportDataInput {
  part_no: Int
  cases: CasesUpdateManyWithoutVolInput
  year: Int
}

input VolUpdateWithWhereUniqueWithoutReportInput {
  where: VolWhereUniqueInput!
  data: VolUpdateWithoutReportDataInput!
}

input VolUpsertWithoutCasesInput {
  update: VolUpdateWithoutCasesDataInput!
  create: VolCreateWithoutCasesInput!
}

input VolUpsertWithWhereUniqueWithoutReportInput {
  where: VolWhereUniqueInput!
  update: VolUpdateWithoutReportDataInput!
  create: VolCreateWithoutReportInput!
}

input VolWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  part_no: Int
  part_no_not: Int
  part_no_in: [Int!]
  part_no_not_in: [Int!]
  part_no_lt: Int
  part_no_lte: Int
  part_no_gt: Int
  part_no_gte: Int
  cases_every: CasesWhereInput
  cases_some: CasesWhereInput
  cases_none: CasesWhereInput
  year: Int
  year_not: Int
  year_in: [Int!]
  year_not_in: [Int!]
  year_lt: Int
  year_lte: Int
  year_gt: Int
  year_gte: Int
  report: ReportWhereInput
  AND: [VolWhereInput!]
  OR: [VolWhereInput!]
  NOT: [VolWhereInput!]
}

input VolWhereUniqueInput {
  id: ID
}
`
      }
    